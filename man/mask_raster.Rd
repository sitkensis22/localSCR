% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/localSCR.R
\name{mask_raster}
\alias{mask_raster}
\title{Function to create habitat mask matrix or array from raster}
\usage{
mask_raster(rast, FUN, grid, crs_, prev_mask)
}
\arguments{
\item{rast}{a raster layer created using the \code{raster} package of class \code{"RasterLayer"}}

\item{FUN}{a function that defines the criteria for suitable habitat.}

\item{grid}{a matrix or array object of the the state-space grid. This is returned from \code{\link{grid_classic}}.}

\item{crs_}{the UTM coordinate reference system (EPSG code) used for your
location provided as an integer (e.g., 32608 for WGS 84/UTM Zone 8N).}

\item{prev_mask}{either \code{NULL} or a previously created habitat mask matrix or array from \code{\link{mask_polygon}} or \code{\link{mask_raster}}. This allows for habitat masks to be combined to account for different spatial features.}
}
\value{
a matrix or array of 0's and 1's denoting unsuitable and suitable habitat respectively.
}
\description{
Creates a matrix or array to use as a habitat mask to account for unsuitable habitat
}
\details{
This function creates a habitat matrix or array depending upon whether a 2D (former) or 3D (latter) trap array is used. This matrix can be directly included as data in Bayesian SCR models run using \code{nimble}.
}
\examples{
# simulate a single trap array with random positional noise
x <- seq(-800, 800, length.out = 5)
y <- seq(-800, 800, length.out = 5)
traps <- as.matrix(expand.grid(x = x, y = y))
traps <- traps + runif(prod(dim(traps)),-20,20) # add some random noise to locations

mysigma = 300 # simulate sigma of 300 m
mycrs = 32608 # EPSG for WGS 84 / UTM zone 8N

# create state-space grid and extent
Grid = grid_classic(X = traps, crs_ = mycrs, buff = 3*mysigma, res = 100)

# run previous code used for mask_polygon() to create raster for example
library(sf)
poly = st_sfc(st_polygon(x=list(matrix(c(-1665,-1665,1730,-1650,1600,1650,0,1350,-800,1700,-1850,1000,-1665,-1665),ncol=2, byrow=TRUE))), crs =  mycrs)
hab_mask = mask_polygon(poly = poly, grid = Grid$grid, crs_ = mycrs, prev_mask = NULL)

# create raster for demonstration purposes
rast <- raster(nrow=dim(hab_mask)[1], ncol=dim(hab_mask)[2],ext=Grid$ext,crs=CRS(st_crs(mycrs)$proj4string))
rast[] = apply(hab_mask,2,rev)

# create habitat mask using raster
hab_mask_r = mask_raster(rast = rast, FUN = function(x){x==1}, grid = Grid$grid, crs_ = mycrs, prev_mask = NULL)

# make simple plot
plot(raster(apply(hab_mask_r,2,rev))) # returns idential results as input rast (but this was just an example raster)

# create an array of traps, as an approach where individuals will only be detected at one of the trap arrays (e.g., Furnas et al. 2018)
Xarray = array(NA, dim=c(nrow(traps),2,2))
Xarray[,,1]=traps
Xarray[,,2]=traps+4000 # shift trapping grid to new locations

# create grid and extent for 3D trap array
GridX = grid_classic(X = Xarray, crs_ = mycrs, buff = 3*mysigma, res = 100)

# make simple plot
par(mfrow=c(1,1))
plot(GridX$grid[,,1],xlim=c(-1600,6000),ylim=c(-1600,6000),col="darkgrey",pch=20,ylab="Northing",xlab="Easting")
points(Xarray[,,1],col="blue",pch=20)
points(GridX$grid[,,2],pch=20,col="darkgrey")
points(Xarray[,,2],col="blue",pch=20)

# create polygon to use as a mask and covert to raster
poly = st_sfc(st_polygon(x=list(matrix(c(-1660,-1900,5730,-1050,5470,5650,0,6050,-1800,5700,-1660,-1900),ncol=2, byrow=TRUE))), crs =  mycrs)

# add polygon to plot
plot(poly, add=TRUE)

# make raster from polygon
rast = raster(xmn=-2000, xmx=6000, ymn=-2000, ymx=6500,res=100,crs=CRS(st_crs(mycrs)$proj4string))
rast[]=st_intersects(st_cast(st_sfc(st_multipoint(coordinates(rast)), crs =  mycrs),"POINT"),poly,sparse=FALSE)

# make simple plot of raster
plot(rast)

# get 3D habitat mask array for 3D grid
hab_mask = mask_raster(rast = rast, FUN = function(x){x==1}, grid = GridX$grid, crs_ = mycrs, prev_mask = NULL)
par(mfrow=c(1,2))
apply(hab_mask,3,function(x) plot(raster(apply(x,2,rev))))
}
\seealso{
\code{\link{mask_polygon}}
}
\author{
Daniel Eacker
}
