<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>Spatial count models: continuous state-space and unmarked individuals • localSCR</title><!-- jquery --><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script><!-- Bootstrap --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/css/bootstrap.min.css" integrity="sha256-bZLfwXAP04zRMK2BjiO8iu9pf4FbLqX6zitd+tIvLhE=" crossorigin="anonymous"><script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/js/bootstrap.min.js" integrity="sha256-nuL8/2cJ5NDSSwnKD8VqreErSWHtnEP9E7AySL+1ev4=" crossorigin="anonymous"></script><!-- bootstrap-toc --><link rel="stylesheet" href="../bootstrap-toc.css"><script src="../bootstrap-toc.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous"><!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet"><script src="../pkgdown.js"></script><meta property="og:title" content="Spatial count models: continuous state-space and unmarked individuals"><meta property="og:description" content="Learn how to simulate and analyze basic spatial count data in a SCR framework
"><!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]--></head><body data-spy="scroll" data-target="#toc">
    

    <div class="container template-article">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">localSCR</a>
        <span class="version label label-default" data-toggle="tooltip" data-placement="bottom" title="">0.1.0</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav"><li>
  <a href="../reference/index.html">Reference</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Articles
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu"><li>
      <a href="../articles/classic_scr.html">Classic SCR models: continuous state-space and marked individuals</a>
    </li>
    <li>
      <a href="../articles/discrete_scr.html">Discrete SCR models: discrete state-space and marked individuals</a>
    </li>
    <li>
      <a href="../articles/local_classic_scr.html">Local classic SCR models: continuous state-space and marked individuals</a>
    </li>
    <li>
      <a href="../articles/mark_resight_scr.html">Mark-resight models: continuous state-space with both marked and unmarked individuals</a>
    </li>
    <li>
      <a href="../articles/unmarked_scr.html">Spatial count models: continuous state-space and unmarked individuals</a>
    </li>
  </ul></li>
      </ul><ul class="nav navbar-nav navbar-right"></ul></div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

      

      </header>




<script src="unmarked_scr_files/accessible-code-block-0.0.1/empty-anchor.js"></script>

<div class="row">
  <div class="col-md-9 contents">
    <div class="page-header toc-ignore">
      <h1 data-toc-skip>Spatial count models: continuous state-space and unmarked individuals</h1>
                        <h4 data-toc-skip class="author">Daniel Eacker</h4>
            
            <h4 data-toc-skip class="date">2022-05-14</h4>
      
      
      <div class="hidden name"><code>unmarked_scr.Rmd</code></div>

    </div>

    
    
<div id="introduction" class="section level2">
<h2>Introduction</h2>
<p>
The second vignette of the ‘localSCR’ package builds on ‘classic’ Bayesian spatial capture-recapture (SCR) models to introduce the spatial count model (Royle et al. 2014). The data consist of counts of unmarked individuals where individual identity is not possible. These models are designed to model SCR data for ‘marked’ or ‘unmarked’ individuals under the assumption of uniformly distributed activity centers (i.e,. a continuous state-space). Although many distance detection functions are possible, the package currently includes only a bivariate normal model of space use, which is commonly employed in the literature. The package is meant to ease implementation of Bayesian SCR models using the ‘nimble’ package (de Valpine et a. 2022), which allows for increased flexibilty with the ability for the user to include custom functions and assign different algorithms to specific model parameters. I took advantage of this functionality with the goal of building a simple, straightforward workflow that was flexible enough to handle most mainstream SCR analysis problems. Visit <a href="https://r-nimble.org/download" class="uri">https://r-nimble.org/download</a> for information on installing ‘nimble’ and Rtools on your computer.
</p>
<p><br></p>
</div>
<div id="implementation" class="section level2">
<h2>Implementation</h2>
<p>
<p>The ‘localSCR’ package implements Bayesian spatial count models using the ‘nimble’ package (de Valpine et a. 2022) following methods described in Royle et al. (2014). We take advantage of recent developments in computation of SCR models. In this tutorial, two methods are implemented to decrease computational run time:</p>
<ol style="list-style-type: decimal">
<li>Block updating of x and y activity center coordinates (Turek et al. 2021)</li>
<li>Using vectorized declarations for traps in distance function calculations</li>
</ol>
<p>In some SCR problems, there are landscape features that create ‘unsuitable’ habitat for the study species. Habitat masks are used to account for these features and designate suitable (1) or unsuitable (0) habitat, and can be represented as a matrix or array of binary values. We follow the methods of Milleret et al. (2019) to implement the “ones” trick to account for habitat suitability. This restricts the possible locations of latent activity centers to only suitable habitat. The ‘localSCR’ package provides functions to construct a habitat mask from either raster or polygon data.</p>
Finally, in some SCR designs, clusters of trap arrays may be spread out over the study area such that individuals can only be detected at one of multiple trap arrays (e.g., Furnas et al. 2018). This necessitates including the traps as a 3-dimensional array, using a site identifier to track which site a detected or augmented individual belongs to, and using a dynamic indexing in the model.
</p>
<p><br></p>
<p>
</div>
<div id="functions-used-from-localscr-package" class="section level2">
<h2>Functions used from ‘localSCR’ package:</h2>
<ul>
<li><code>customize_model()</code> delete and/or append lines from model code</li>
<li><code>get_unmarked()</code> grabs spatial count model for given inputs using the <code>nimbleCode()</code> function</li>
<li><code>grid_classic()</code> define state-space grid and extent</li>
<li><code>initialize_classic()</code> generate starting locations for activity area centers</li>
<li><code>mask_polygon()</code> create habitat mask matrix or array from polygon</li>
<li><code>nimSummary()</code> summarize lists of Markov Chain Monte Carlo (MCMC) output</li>
<li><code>realized_density()</code> generate realized density surface from MCMC output</li>
<li><code>rescale_classic()</code> rescale inputs to prepare data for using habitat mask</li>
<li><code>run_classic()</code> wrapper function to run classic models using ‘nimble’ package</li>
<li><code>sim_classic()</code> simulate basic spatial capture-recapture data</li>
</ul>
</p>
<p><br></p>
<p>
</div>
<div id="turtorial" class="section level2">
<h2>Turtorial</h2>
<p>This tutorial includes five parts:</p>
<ol style="list-style-type: decimal">
<li>Create traps (or detectors) and then construct a state-space</li>
<li>Simulate ‘classic’ SCR data and covert to spatial count data<br />
</li>
<li>Workflow for 2D trap array including habitat mask</li>
<li>Adding prior information on the scaling and encounter rate parameters</li>
<li>Workflow for 3D trap array including habitat mask</li>
</ol>
</p>
<p><br></p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1"></a><span class="co"># load &#39;localSCR&#39; package</span></span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="kw">library</span>(localSCR)</span>
<span id="cb1-3"><a href="#cb1-3"></a><span class="co">#&gt; Loading required package: nimble</span></span>
<span id="cb1-4"><a href="#cb1-4"></a><span class="co">#&gt; nimble version 0.12.2 is loaded.</span></span>
<span id="cb1-5"><a href="#cb1-5"></a><span class="co">#&gt; For more information on NIMBLE and a User Manual,</span></span>
<span id="cb1-6"><a href="#cb1-6"></a><span class="co">#&gt; please visit https://R-nimble.org.</span></span>
<span id="cb1-7"><a href="#cb1-7"></a><span class="co">#&gt; </span></span>
<span id="cb1-8"><a href="#cb1-8"></a><span class="co">#&gt; Attaching package: &#39;nimble&#39;</span></span>
<span id="cb1-9"><a href="#cb1-9"></a><span class="co">#&gt; The following object is masked from &#39;package:stats&#39;:</span></span>
<span id="cb1-10"><a href="#cb1-10"></a><span class="co">#&gt; </span></span>
<span id="cb1-11"><a href="#cb1-11"></a><span class="co">#&gt;     simulate</span></span></code></pre></div>
<p><br></p>
<div id="simulate-a-single-trap-array-with-random-positional-noise-and-create-state-space" class="section level3">
<h3>(1) Simulate a single trap array with random positional noise and create state-space</h3>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1"></a><span class="co"># simulate a single trap array with random positional noise</span></span>
<span id="cb2-2"><a href="#cb2-2"></a>x &lt;-<span class="st"> </span><span class="kw">seq</span>(<span class="op">-</span><span class="dv">800</span>, <span class="dv">800</span>, <span class="dt">length.out =</span> <span class="dv">5</span>)</span>
<span id="cb2-3"><a href="#cb2-3"></a>y &lt;-<span class="st"> </span><span class="kw">seq</span>(<span class="op">-</span><span class="dv">800</span>, <span class="dv">800</span>, <span class="dt">length.out =</span> <span class="dv">5</span>)</span>
<span id="cb2-4"><a href="#cb2-4"></a>traps &lt;-<span class="st"> </span><span class="kw">as.matrix</span>(<span class="kw">expand.grid</span>(<span class="dt">x =</span> x, <span class="dt">y =</span> y))</span>
<span id="cb2-5"><a href="#cb2-5"></a><span class="kw">set.seed</span>(<span class="dv">200</span>)</span>
<span id="cb2-6"><a href="#cb2-6"></a>traps &lt;-<span class="st"> </span>traps <span class="op">+</span><span class="st"> </span><span class="kw">runif</span>(<span class="kw">prod</span>(<span class="kw">dim</span>(traps)),<span class="op">-</span><span class="dv">20</span>,<span class="dv">20</span>) </span>
<span id="cb2-7"><a href="#cb2-7"></a></span>
<span id="cb2-8"><a href="#cb2-8"></a>mysigma =<span class="st"> </span><span class="dv">300</span> <span class="co"># simulate sigma of 300 m</span></span>
<span id="cb2-9"><a href="#cb2-9"></a>mycrs =<span class="st"> </span><span class="dv">32608</span> <span class="co"># EPSG for WGS 84 / UTM zone 8N</span></span>
<span id="cb2-10"><a href="#cb2-10"></a></span>
<span id="cb2-11"><a href="#cb2-11"></a><span class="co"># create state-space</span></span>
<span id="cb2-12"><a href="#cb2-12"></a>Grid =<span class="st"> </span><span class="kw">grid_classic</span>(<span class="dt">X =</span> traps, <span class="dt">crs_ =</span> mycrs, <span class="dt">buff =</span> <span class="dv">3</span><span class="op">*</span>mysigma, <span class="dt">res =</span> <span class="dv">100</span>)</span>
<span id="cb2-13"><a href="#cb2-13"></a></span>
<span id="cb2-14"><a href="#cb2-14"></a><span class="co"># make ggplot of grid and trap locations</span></span>
<span id="cb2-15"><a href="#cb2-15"></a><span class="kw">library</span>(ggplot2)</span>
<span id="cb2-16"><a href="#cb2-16"></a><span class="kw">ggplot</span>() <span class="op">+</span><span class="st"> </span><span class="kw">geom_point</span>(<span class="dt">data=</span><span class="kw">as.data.frame</span>(Grid<span class="op">$</span>grid),<span class="kw">aes</span>(<span class="dt">x=</span>x,<span class="dt">y=</span>y),</span>
<span id="cb2-17"><a href="#cb2-17"></a>                      <span class="dt">color=</span><span class="st">&quot;grey60&quot;</span>, <span class="dt">size=</span><span class="fl">1.25</span>) <span class="op">+</span><span class="st"> </span></span>
<span id="cb2-18"><a href="#cb2-18"></a><span class="st">    </span><span class="kw">geom_point</span>(<span class="dt">data=</span><span class="kw">as.data.frame</span>(traps),<span class="kw">aes</span>(<span class="dt">x=</span>x,<span class="dt">y=</span>y),<span class="dt">color=</span><span class="st">&quot;blue&quot;</span>,<span class="dt">size=</span><span class="dv">2</span>) <span class="op">+</span></span>
<span id="cb2-19"><a href="#cb2-19"></a><span class="st">    </span><span class="kw">theme_classic</span>() <span class="op">+</span><span class="st"> </span><span class="kw">ylab</span>(<span class="st">&quot;Northing&quot;</span>) <span class="op">+</span><span class="st"> </span><span class="kw">xlab</span>(<span class="st">&quot;Easting&quot;</span>) <span class="op">+</span></span>
<span id="cb2-20"><a href="#cb2-20"></a><span class="st">    </span><span class="kw">scale_x_continuous</span>(<span class="dt">expand=</span><span class="kw">c</span>(<span class="op">-</span><span class="fl">0.1</span>, <span class="fl">0.1</span>)) <span class="op">+</span><span class="st"> </span></span>
<span id="cb2-21"><a href="#cb2-21"></a><span class="st">    </span><span class="kw">scale_y_continuous</span>(<span class="dt">expand=</span><span class="kw">c</span>(<span class="op">-</span><span class="fl">0.1</span>, <span class="fl">0.1</span>)) <span class="op">+</span><span class="st"> </span></span>
<span id="cb2-22"><a href="#cb2-22"></a><span class="st">    </span><span class="kw">theme</span>(<span class="dt">axis.text =</span> <span class="kw">element_text</span>(<span class="dt">size=</span><span class="dv">12</span>),<span class="dt">axis.title =</span> <span class="kw">element_text</span>(<span class="dt">size=</span><span class="dv">16</span>))</span></code></pre></div>
<br>
<p align="center">
<img src="../man/figures/vignette_02/Fig1.png" style="width:70%"/>
</p>
<br>
<p>
<p>Here, we use the same approach as in the first vignette in creating the state-space from <code>grid_classic()</code>. Again, the traps (or detectors) are plotted over top of the grid in blue. We arbitrarily chose a grid resolution of 100 in this example (i.g., <code>res = 100</code>), but this will vary by problem. In situations involving habitat masks or discrete models, it is prudent to test the effect of different grid resolutions on the estimated abundance and density in SCR models (see Royle et al. 2014). Also, note the use to the EPSG code to define the coordinate reference system for our state-space (see <a href="https://epsg.io/32608" class="uri">https://epsg.io/32608</a>).</p>
Now lets first simulate some spatial capture-recapture data using <code>sim_classic()</code>. Importantly, we use <code>enc_dist = "poisson"</code> to select the Poisson distribution to simulate counts rather than binary data. We will use this simulated data to produce our spatial count data of unmarked individuals. Note for this example, we will simulate a ‘true’ population size of 200 individuals (<code>N = 200</code>), 4 sampling occasions (<code>K = 4</code>), a scaling parameter (<code>sigma_</code>) of 300 m, a baseline encounter rate of 0.10 (<code>base_encounter = 0.10</code>), no sex-specificity (<code>prop_sex = 1</code>), and no habitat mask (<code>hab_mask = FALSE</code>). We also use <code>setSeed = 100</code> to make the simulation reproducible. Again, we provide the function the extent of the state-space output from <code>grid_classic()</code> as <code>ext = Grid$ext</code>. Note that Grid is a list.
</p>
<p><br></p>
</div>
<div id="simulate-scr-data-and-convert-it-to-spatial-count-data" class="section level3">
<h3>(2) Simulate SCR data and convert it to spatial count data</h3>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1"></a><span class="co"># simulate SCR data</span></span>
<span id="cb3-2"><a href="#cb3-2"></a>data3d =<span class="st"> </span><span class="kw">sim_classic</span>(<span class="dt">X =</span> traps, <span class="dt">ext =</span> Grid<span class="op">$</span>ext, <span class="dt">crs_ =</span> mycrs, </span>
<span id="cb3-3"><a href="#cb3-3"></a>                     <span class="dt">sigma_ =</span> mysigma, <span class="dt">prop_sex =</span> <span class="dv">1</span>,<span class="dt">N =</span> <span class="dv">200</span>, <span class="dt">K =</span> <span class="dv">4</span>,</span>
<span id="cb3-4"><a href="#cb3-4"></a>                     <span class="dt">base_encounter =</span> <span class="fl">0.10</span>, <span class="dt">enc_dist =</span> <span class="st">&quot;poisson&quot;</span>, </span>
<span id="cb3-5"><a href="#cb3-5"></a>                     <span class="dt">hab_mask =</span> <span class="ot">FALSE</span>, <span class="dt">setSeed =</span> <span class="dv">100</span>)</span>
<span id="cb3-6"><a href="#cb3-6"></a></span>
<span id="cb3-7"><a href="#cb3-7"></a><span class="co"># inspect simulated data</span></span>
<span id="cb3-8"><a href="#cb3-8"></a><span class="kw">str</span>(data3d)</span>
<span id="cb3-9"><a href="#cb3-9"></a><span class="co">#&gt; List of 3</span></span>
<span id="cb3-10"><a href="#cb3-10"></a><span class="co">#&gt;  $ y  : int [1:200, 1:25, 1:4] 0 0 0 0 0 0 0 0 0 0 ...</span></span>
<span id="cb3-11"><a href="#cb3-11"></a><span class="co">#&gt;  $ sex: int [1:200] 1 1 1 1 1 1 1 1 1 1 ...</span></span>
<span id="cb3-12"><a href="#cb3-12"></a><span class="co">#&gt;  $ s  : num [1:200, 1:2] -662 -834 177 -1526 -110 ...</span></span>
<span id="cb3-13"><a href="#cb3-13"></a><span class="co">#&gt;   ..- attr(*, &quot;dimnames&quot;)=List of 2</span></span>
<span id="cb3-14"><a href="#cb3-14"></a><span class="co">#&gt;   .. ..$ : NULL</span></span>
<span id="cb3-15"><a href="#cb3-15"></a><span class="co">#&gt;   .. ..$ : chr [1:2] &quot;sx&quot; &quot;sy&quot;</span></span>
<span id="cb3-16"><a href="#cb3-16"></a></span>
<span id="cb3-17"><a href="#cb3-17"></a><span class="co"># We sum over traps and occasions to produce a 2-dimensional spatial count data set</span></span>
<span id="cb3-18"><a href="#cb3-18"></a>n =<span class="st"> </span><span class="kw">apply</span>(data3d<span class="op">$</span>y, <span class="kw">c</span>(<span class="dv">2</span>,<span class="dv">3</span>), sum)</span>
<span id="cb3-19"><a href="#cb3-19"></a></span>
<span id="cb3-20"><a href="#cb3-20"></a><span class="co"># inspect n[j,k]</span></span>
<span id="cb3-21"><a href="#cb3-21"></a><span class="kw">str</span>(n)</span>
<span id="cb3-22"><a href="#cb3-22"></a><span class="co">#&gt; int [1:25, 1:4] 0 3 2 0 1 1 1 1 1 1 ...</span></span></code></pre></div>
<br>
<p>
<p>We can see the data were transformed from a 3-dimensional array (<code>y[i,j,k]</code>) to a 2-dimensional array (<code>n[j,k]</code>) by summing over traps and occasions. In the spatial count model, we cannot identify individuals but we can observe a count of unmarked individuals at each occasion and trap (Royle et al. 2014). In general, this model depends on spatial autocorrelation in the observations to estimate model parameters. We’ll see how the estimates compare to a problem with marked individuals that was presented in the first vignette by running an analogous spatial count modeling problem . We’ll use the same trap array but set a single scaling parameter (<code>sigma_</code>) of 300 m.</p>
<p>We add on an additional layer of complexity by introducing a habitat mask. After constructing a polygon feature using the ‘sf’ package, we then use the function <code>mask_polygon()</code> to build a habitat mask as a matrix object. The habitat matrix is either ‘0’ (unsuitable) or ‘1’ (suitable). In the habitat matrix the rows represent the y-coordinate (“Northing”) of the state-space grid and the columns represent the x-coordinate (“Easting”) of the state-space grid. We’ll use this habitat matrix as data below in this part of the tutorial.</p>
We also see the use of <code>initialize_classic()</code>, which generates plausible starting activity center locations for all individuals. Note that because all individuals are unmarked here, we’ll use the <code>all_random = TRUE</code> argument in <code>initialize_classic()</code> to generate all random locations to initialize the activity center coordinates. Given our simulated population size of 200, we specify the total augmented population size (all augmented individuals) at 400 (<code>m = 400</code>).
</p>
<p><br></p>
</div>
<div id="workflow-for-spatial-count-model-with-poisson-encounter-distribution-and-habitat-mask-using-a-2d-trap-array." class="section level3">
<h3>(3) Workflow for spatial count model with Poisson encounter distribution and habitat mask using a 2D trap array.</h3>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1"></a><span class="co"># simulate a single trap array with random positional noisee</span></span>
<span id="cb4-2"><a href="#cb4-2"></a>x &lt;-<span class="st"> </span><span class="kw">seq</span>(<span class="op">-</span><span class="dv">800</span>, <span class="dv">800</span>, <span class="dt">length.out =</span> <span class="dv">5</span>)</span>
<span id="cb4-3"><a href="#cb4-3"></a>y &lt;-<span class="st"> </span><span class="kw">seq</span>(<span class="op">-</span><span class="dv">800</span>, <span class="dv">800</span>, <span class="dt">length.out =</span> <span class="dv">5</span>)</span>
<span id="cb4-4"><a href="#cb4-4"></a>traps &lt;-<span class="st"> </span><span class="kw">as.matrix</span>(<span class="kw">expand.grid</span>(<span class="dt">x =</span> x, <span class="dt">y =</span> y))</span>
<span id="cb4-5"><a href="#cb4-5"></a><span class="kw">set.seed</span>(<span class="dv">200</span>)</span>
<span id="cb4-6"><a href="#cb4-6"></a>traps &lt;-<span class="st"> </span>traps <span class="op">+</span><span class="st"> </span><span class="kw">runif</span>(<span class="kw">prod</span>(<span class="kw">dim</span>(traps)),<span class="op">-</span><span class="dv">20</span>,<span class="dv">20</span>) <span class="co"># add some random noise to locations</span></span>
<span id="cb4-7"><a href="#cb4-7"></a></span>
<span id="cb4-8"><a href="#cb4-8"></a>mysigma =<span class="st"> </span><span class="dv">300</span> <span class="co"># simulate a single scaling parameter</span></span>
<span id="cb4-9"><a href="#cb4-9"></a>mycrs =<span class="st"> </span><span class="dv">32608</span> <span class="co"># EPSG for WGS 84 / UTM zone 8N</span></span>
<span id="cb4-10"><a href="#cb4-10"></a>pixelWidth =<span class="st"> </span><span class="dv">100</span> <span class="co"># store pixelWidth or grid resolution</span></span>
<span id="cb4-11"><a href="#cb4-11"></a></span>
<span id="cb4-12"><a href="#cb4-12"></a><span class="co"># create state-space grid and extent</span></span>
<span id="cb4-13"><a href="#cb4-13"></a>Grid =<span class="st"> </span><span class="kw">grid_classic</span>(<span class="dt">X =</span> traps, <span class="dt">crs_ =</span> mycrs, <span class="dt">buff =</span> <span class="dv">3</span><span class="op">*</span><span class="kw">max</span>(mysigma), <span class="dt">res =</span> pixelWidth) </span>
<span id="cb4-14"><a href="#cb4-14"></a></span>
<span id="cb4-15"><a href="#cb4-15"></a><span class="co"># create polygon for mask</span></span>
<span id="cb4-16"><a href="#cb4-16"></a><span class="kw">library</span>(sf)</span>
<span id="cb4-17"><a href="#cb4-17"></a>poly =<span class="st"> </span><span class="kw">st_sfc</span>(<span class="kw">st_polygon</span>(<span class="dt">x=</span><span class="kw">list</span>(<span class="kw">matrix</span>(<span class="kw">c</span>(<span class="op">-</span><span class="dv">1765</span>,<span class="op">-</span><span class="dv">1765</span>,<span class="dv">1730</span>,<span class="op">-</span><span class="dv">1650</span>,<span class="dv">1600</span>,<span class="dv">1650</span>,<span class="dv">0</span>,<span class="dv">1350</span>,<span class="op">-</span><span class="dv">800</span>,<span class="dv">1700</span>,</span>
<span id="cb4-18"><a href="#cb4-18"></a><span class="dv">-1850</span>,<span class="dv">1000</span>,<span class="op">-</span><span class="dv">1765</span>,<span class="op">-</span><span class="dv">1765</span>),<span class="dt">ncol=</span><span class="dv">2</span>, <span class="dt">byrow=</span><span class="ot">TRUE</span>))), <span class="dt">crs =</span>  mycrs)</span>
<span id="cb4-19"><a href="#cb4-19"></a></span>
<span id="cb4-20"><a href="#cb4-20"></a><span class="co"># create habitat mask</span></span>
<span id="cb4-21"><a href="#cb4-21"></a>hab_mask =<span class="st"> </span><span class="kw">mask_polygon</span>(<span class="dt">poly =</span> poly, <span class="dt">grid =</span> Grid<span class="op">$</span>grid, <span class="dt">crs_ =</span> mycrs, </span>
<span id="cb4-22"><a href="#cb4-22"></a>                        <span class="dt">prev_mask =</span> <span class="ot">NULL</span>)</span>
<span id="cb4-23"><a href="#cb4-23"></a></span>
<span id="cb4-24"><a href="#cb4-24"></a><span class="co"># simulate data for uniform state-space and habitat mask</span></span>
<span id="cb4-25"><a href="#cb4-25"></a>data3d =<span class="st"> </span><span class="kw">sim_classic</span>(<span class="dt">X =</span> traps, <span class="dt">ext =</span> Grid<span class="op">$</span>ext, <span class="dt">crs_ =</span> mycrs, </span>
<span id="cb4-26"><a href="#cb4-26"></a>            <span class="dt">sigma_ =</span> mysigma, <span class="dt">prop_sex =</span> <span class="dv">1</span>,<span class="dt">N =</span> <span class="dv">200</span>, <span class="dt">K =</span> <span class="dv">4</span>, </span>
<span id="cb4-27"><a href="#cb4-27"></a>            <span class="dt">base_encounter =</span> <span class="fl">0.3</span>, <span class="dt">enc_dist =</span> <span class="st">&quot;poisson&quot;</span>,</span>
<span id="cb4-28"><a href="#cb4-28"></a>            <span class="dt">hab_mask =</span> hab_mask, <span class="dt">setSeed =</span> <span class="dv">100</span>)</span>
<span id="cb4-29"><a href="#cb4-29"></a></span>
<span id="cb4-30"><a href="#cb4-30"></a></span>
<span id="cb4-31"><a href="#cb4-31"></a><span class="co"># total augmented population size </span></span>
<span id="cb4-32"><a href="#cb4-32"></a>m =<span class="st"> </span><span class="dv">500</span></span>
<span id="cb4-33"><a href="#cb4-33"></a></span>
<span id="cb4-34"><a href="#cb4-34"></a><span class="co"># get initial activity center starting values</span></span>
<span id="cb4-35"><a href="#cb4-35"></a>s.st3d =<span class="st"> </span><span class="kw">initialize_classic</span>(<span class="dt">y=</span><span class="ot">NULL</span>, <span class="dt">M=</span>m, <span class="dt">X=</span>traps, <span class="dt">ext =</span> Grid<span class="op">$</span>ext, </span>
<span id="cb4-36"><a href="#cb4-36"></a>                            <span class="dt">hab_mask =</span> hab_mask, <span class="dt">all_random=</span><span class="ot">TRUE</span>)</span>
<span id="cb4-37"><a href="#cb4-37"></a>  </span>
<span id="cb4-38"><a href="#cb4-38"></a><span class="co"># make ggplot</span></span>
<span id="cb4-39"><a href="#cb4-39"></a><span class="kw">ggplot</span>() <span class="op">+</span><span class="st"> </span><span class="kw">geom_point</span>(<span class="dt">data=</span><span class="kw">as.data.frame</span>(Grid<span class="op">$</span>grid),<span class="kw">aes</span>(<span class="dt">x=</span>x,<span class="dt">y=</span>y),<span class="dt">color=</span><span class="st">&quot;grey60&quot;</span>,</span>
<span id="cb4-40"><a href="#cb4-40"></a>                      <span class="dt">size=</span><span class="fl">1.25</span>) <span class="op">+</span><span class="st"> </span></span>
<span id="cb4-41"><a href="#cb4-41"></a><span class="st">    </span><span class="kw">geom_point</span>(<span class="dt">data=</span><span class="kw">as.data.frame</span>(traps),<span class="kw">aes</span>(<span class="dt">x=</span>x,<span class="dt">y=</span>y),<span class="dt">color=</span><span class="st">&quot;blue&quot;</span>,<span class="dt">size=</span><span class="dv">3</span>) <span class="op">+</span></span>
<span id="cb4-42"><a href="#cb4-42"></a><span class="st">    </span><span class="kw">geom_point</span>(<span class="dt">data=</span><span class="kw">as.data.frame</span>(s.st3d),<span class="kw">aes</span>(<span class="dt">x=</span>V1,<span class="dt">y=</span>V2),<span class="dt">color =</span> <span class="st">&quot;orangered&quot;</span>,<span class="dt">size=</span><span class="fl">2.5</span>,<span class="dt">alpha=</span><span class="fl">0.5</span>) <span class="op">+</span></span>
<span id="cb4-43"><a href="#cb4-43"></a><span class="st">    </span><span class="kw">geom_sf</span>(<span class="dt">data=</span>poly, <span class="dt">fill =</span> <span class="ot">NA</span>) <span class="op">+</span><span class="st"> </span><span class="kw">coord_sf</span>(<span class="dt">datum=</span><span class="kw">st_crs</span>(mycrs)) <span class="op">+</span></span>
<span id="cb4-44"><a href="#cb4-44"></a><span class="st">    </span><span class="kw">theme_classic</span>() <span class="op">+</span><span class="st"> </span><span class="kw">ylab</span>(<span class="st">&quot;Northing&quot;</span>) <span class="op">+</span><span class="st"> </span><span class="kw">xlab</span>(<span class="st">&quot;Easting&quot;</span>) <span class="op">+</span></span>
<span id="cb4-45"><a href="#cb4-45"></a><span class="st">    </span><span class="kw">scale_x_continuous</span>(<span class="dt">expand=</span><span class="kw">c</span>(<span class="fl">0.025</span>, <span class="fl">0.025</span>)) <span class="op">+</span><span class="st"> </span></span>
<span id="cb4-46"><a href="#cb4-46"></a><span class="st">    </span><span class="kw">scale_y_continuous</span>(<span class="dt">expand=</span><span class="kw">c</span>(<span class="fl">0.025</span>, <span class="fl">0.025</span>)) <span class="op">+</span><span class="st"> </span></span>
<span id="cb4-47"><a href="#cb4-47"></a><span class="st">    </span><span class="kw">theme</span>(<span class="dt">axis.text =</span> <span class="kw">element_text</span>(<span class="dt">size=</span><span class="dv">12</span>),<span class="dt">axis.title =</span> <span class="kw">element_text</span>(<span class="dt">size=</span><span class="dv">16</span>))</span></code></pre></div>
<p align="center">
<img src="../man/figures/vignette_02/Fig2.png" style="width:70%" />
</p>
<br>
<p>
<p>In the figure above we can see the effect of the polygon in creating a habitat mask for the state-space. The <code>initialize_classic()</code> function contains the initial activity center locations to within the polygon (note that those points on the edges were in suitable habitat when the continuous location were discretized and checked with the habitat mask).</p>
<p>We now have most of the components we will need to analyze the simulated data set. However, because we are using a habitat mask in the model (<code>hab_mask</code>), we must rescale the traps, grid extent, and initial activity center locations. To run the spatial count model using the template model from <code>get_unmarked()</code>, we’ll need to change the parameter names <code>"s"</code> and <code>"z"</code> to <code>"su"</code> and <code>"zu"</code> in <code>params</code> to denote that these are unmarked individuals. We also set the <code>s_alias = "su"</code> argument in <code>run_classic()</code>. This allows the block updating of x- and y- activity center coordinates to function properly. Additionally, we have the <code>zu</code> parameter initialized with <code>rbinom</code> rather than separating the data augmentation as in vignette 1 with the marked individuals.</p>
<p>Because the model uses the Poisson encounter distribution, we also need to initialize the encounter rate <code>lam0</code> rather than the encounter probability <code>p0</code> as in the binomial likelihood. We also need to add <code>lam0</code> to <code>params</code> and <code>lam0_upper</code> to <code>constants</code> given the default uniform distribution used in the model (i.e., <code>lam0 ~ dunif(0, lam0_upper)</code>).</p>
</p>
<p><br></p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1"></a><span class="co"># rescale inputs</span></span>
<span id="cb5-2"><a href="#cb5-2"></a>rescale_list =<span class="st"> </span><span class="kw">rescale_classic</span>(<span class="dt">X =</span> traps, <span class="dt">ext =</span> Grid<span class="op">$</span>ext, <span class="dt">s.st =</span> s.st3d, </span>
<span id="cb5-3"><a href="#cb5-3"></a>                               <span class="dt">hab_mask =</span> hab_mask)</span>
<span id="cb5-4"><a href="#cb5-4"></a></span>
<span id="cb5-5"><a href="#cb5-5"></a><span class="co"># store rescaled extent</span></span>
<span id="cb5-6"><a href="#cb5-6"></a>ext =<span class="st"> </span>rescale_list<span class="op">$</span>ext</span>
<span id="cb5-7"><a href="#cb5-7"></a></span>
<span id="cb5-8"><a href="#cb5-8"></a><span class="co"># Prepare data by summing over traps and occasions and add to list</span></span>
<span id="cb5-9"><a href="#cb5-9"></a>data =<span class="st"> </span><span class="kw">list</span>(<span class="dt">n =</span> <span class="kw">apply</span>(data3d<span class="op">$</span>y, <span class="kw">c</span>(<span class="dv">2</span>,<span class="dv">3</span>), sum))</span>
<span id="cb5-10"><a href="#cb5-10"></a></span>
<span id="cb5-11"><a href="#cb5-11"></a><span class="co"># add rescaled traps</span></span>
<span id="cb5-12"><a href="#cb5-12"></a>data<span class="op">$</span>X =<span class="st"> </span>rescale_list<span class="op">$</span>X</span>
<span id="cb5-13"><a href="#cb5-13"></a></span>
<span id="cb5-14"><a href="#cb5-14"></a><span class="co"># prepare constants (note get density in activity center/100 m2 rather than activity centers/m2)</span></span>
<span id="cb5-15"><a href="#cb5-15"></a>constants =<span class="st"> </span><span class="kw">list</span>(<span class="dt">m =</span> m,<span class="dt">J=</span><span class="kw">dim</span>(data3d<span class="op">$</span>y)[<span class="dv">2</span>], <span class="dt">K=</span><span class="kw">dim</span>(data3d<span class="op">$</span>y)[<span class="dv">3</span>],</span>
<span id="cb5-16"><a href="#cb5-16"></a><span class="dt">x_lower =</span> ext[<span class="dv">1</span>], <span class="dt">x_upper =</span> ext[<span class="dv">2</span>], <span class="dt">y_lower =</span> ext[<span class="dv">3</span>], <span class="dt">y_upper =</span> ext[<span class="dv">4</span>],</span>
<span id="cb5-17"><a href="#cb5-17"></a><span class="dt">lam0_upper =</span> <span class="dv">1</span>,<span class="dt">sigma_upper =</span> <span class="dv">1000</span>, </span>
<span id="cb5-18"><a href="#cb5-18"></a><span class="dt">A =</span> (<span class="kw">sum</span>(hab_mask)<span class="op">*</span>(pixelWidth<span class="op">/</span><span class="dv">100</span>)<span class="op">^</span><span class="dv">2</span>),<span class="dt">pixelWidth=</span>pixelWidth)</span>
<span id="cb5-19"><a href="#cb5-19"></a></span>
<span id="cb5-20"><a href="#cb5-20"></a><span class="co"># add hab_mask and OK for habitat check</span></span>
<span id="cb5-21"><a href="#cb5-21"></a>data<span class="op">$</span>hab_mask =<span class="st"> </span>hab_mask</span>
<span id="cb5-22"><a href="#cb5-22"></a>data<span class="op">$</span>OKu =<span class="st"> </span><span class="kw">rep</span>(<span class="dv">1</span>,constants<span class="op">$</span>m)</span>
<span id="cb5-23"><a href="#cb5-23"></a></span>
<span id="cb5-24"><a href="#cb5-24"></a><span class="co"># get initial activity center starting values</span></span>
<span id="cb5-25"><a href="#cb5-25"></a>s.st =<span class="st"> </span>rescale_list<span class="op">$</span>s.st</span>
<span id="cb5-26"><a href="#cb5-26"></a></span>
<span id="cb5-27"><a href="#cb5-27"></a><span class="co"># define all initial values</span></span>
<span id="cb5-28"><a href="#cb5-28"></a>inits =<span class="st"> </span><span class="kw">list</span>(<span class="dt">sigma =</span> <span class="kw">runif</span>(<span class="dv">1</span>, <span class="dv">250</span>, <span class="dv">350</span>), <span class="dt">su =</span> s.st,<span class="dt">psiu=</span><span class="kw">runif</span>(<span class="dv">1</span>,<span class="fl">0.4</span>,<span class="fl">0.6</span>),</span>
<span id="cb5-29"><a href="#cb5-29"></a><span class="dt">lam0 =</span> <span class="kw">runif</span>(<span class="dv">1</span>, <span class="fl">0.05</span>, <span class="fl">0.15</span>),<span class="dt">pOKu=</span>data<span class="op">$</span>OKu,<span class="dt">zu=</span><span class="kw">rbinom</span>(constants<span class="op">$</span>m,<span class="dv">1</span>,<span class="fl">0.5</span>))</span>
<span id="cb5-30"><a href="#cb5-30"></a></span>
<span id="cb5-31"><a href="#cb5-31"></a><span class="co"># parameters to monitor</span></span>
<span id="cb5-32"><a href="#cb5-32"></a>params =<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;sigma&quot;</span>,<span class="st">&quot;psiu&quot;</span>,<span class="st">&quot;lam0&quot;</span>,<span class="st">&quot;N&quot;</span>,<span class="st">&quot;D&quot;</span>,<span class="st">&quot;su&quot;</span>,<span class="st">&quot;zu&quot;</span>)</span>
<span id="cb5-33"><a href="#cb5-33"></a></span>
<span id="cb5-34"><a href="#cb5-34"></a><span class="co"># get spatial count model</span></span>
<span id="cb5-35"><a href="#cb5-35"></a>sc_model =<span class="st"> </span><span class="kw">get_unmarked</span>(<span class="dt">occ_specific =</span> <span class="ot">FALSE</span>,</span>
<span id="cb5-36"><a href="#cb5-36"></a>                         <span class="dt">hab_mask=</span><span class="ot">TRUE</span>,<span class="dt">trapsClustered=</span><span class="ot">FALSE</span>)</span>
<span id="cb5-37"><a href="#cb5-37"></a></span>
<span id="cb5-38"><a href="#cb5-38"></a><span class="co"># run model (note we set s_alias to &quot;su&quot; for spatial count model)</span></span>
<span id="cb5-39"><a href="#cb5-39"></a><span class="kw">library</span>(tictoc)</span>
<span id="cb5-40"><a href="#cb5-40"></a><span class="kw">tic</span>() <span class="co"># track time elapsed</span></span>
<span id="cb5-41"><a href="#cb5-41"></a>out =<span class="st"> </span><span class="kw">run_classic</span>(<span class="dt">model =</span> sc_model, <span class="dt">data=</span>data, <span class="dt">constants=</span>constants,</span>
<span id="cb5-42"><a href="#cb5-42"></a><span class="dt">inits=</span>inits, <span class="dt">params =</span> params,<span class="dt">niter =</span> <span class="dv">10000</span>, <span class="dt">nburnin=</span><span class="dv">1000</span>, <span class="dt">thin=</span><span class="dv">1</span>, <span class="dt">nchains=</span><span class="dv">2</span>, <span class="dt">parallel=</span><span class="ot">TRUE</span>,</span>
<span id="cb5-43"><a href="#cb5-43"></a><span class="dt">RNGseed =</span> <span class="dv">500</span>, <span class="dt">s_alias=</span><span class="st">&quot;su&quot;</span>)</span>
<span id="cb5-44"><a href="#cb5-44"></a><span class="kw">toc</span>()</span>
<span id="cb5-45"><a href="#cb5-45"></a><span class="co">#&gt; 511.62 sec elapsed</span></span>
<span id="cb5-46"><a href="#cb5-46"></a></span>
<span id="cb5-47"><a href="#cb5-47"></a><span class="co"># summarize output</span></span>
<span id="cb5-48"><a href="#cb5-48"></a>samples =<span class="st"> </span><span class="kw">do.call</span>(rbind, out)</span>
<span id="cb5-49"><a href="#cb5-49"></a></span>
<span id="cb5-50"><a href="#cb5-50"></a><span class="kw">par</span>(<span class="dt">mfrow=</span><span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">1</span>))</span>
<span id="cb5-51"><a href="#cb5-51"></a><span class="kw">hist</span>(samples[,<span class="kw">which</span>(<span class="kw">dimnames</span>(out[[<span class="dv">1</span>]])[[<span class="dv">2</span>]]<span class="op">==</span><span class="st">&quot;N&quot;</span>)], <span class="dt">xlab =</span> <span class="st">&quot;Abundance&quot;</span>, <span class="dt">xlim =</span> <span class="kw">c</span>(<span class="dv">0</span>,<span class="dv">500</span>), <span class="dt">main=</span><span class="st">&quot;&quot;</span>)</span>
<span id="cb5-52"><a href="#cb5-52"></a><span class="kw">abline</span>(<span class="dt">v=</span><span class="dv">200</span>, <span class="dt">col=</span><span class="st">&quot;red&quot;</span>) <span class="co"># add line for simulated abundance</span></span></code></pre></div>
<p align="center">
<img src="../man/figures/vignette_02/Fig3.png" style="width:70%"/>
</p>
<br>
<p>
<p>Besides taking longer to run, we can see from the histogram of the posterior samples of <code>N</code> that convergence is somewhat poor. This is not surprising given that the model is asking so much of the data in trying to estimate the number of individuals from observing a count of unmarked individuals for a given occasion and trap. We could try increasing the number of iterations, but this is likely futile since there simply is not enough information. We have some other options that we’ll explore in the next part of the tutorial.</p>
<p>In this example, we divided the pixelWidth by 100 in deriving the area (<code>A</code>) in our list of constants. This allowed us to estimate density in activity centers/100 m<sup>2</sup> rather than activity centers/m<sup>2</sup>. Note that care must be taken with any rescaling of the data or constants.</p>
Next we use<code>nimSummary()</code> to quickly summarize the MCMC samples. Note that there are other options to summarize MCMC output, but this function is provided with the package and depends partly on the ‘coda’ package.
</p>
<p><br></p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1"></a><span class="co"># summarize MCMC samples (exclude parameters and don&#39;t plot)</span></span>
<span id="cb6-2"><a href="#cb6-2"></a><span class="kw">nimSummary</span>(out, <span class="dt">exclude =</span> <span class="kw">c</span>(<span class="st">&quot;su&quot;</span>,<span class="st">&quot;zu&quot;</span>), <span class="dt">trace=</span><span class="ot">FALSE</span>)</span>
<span id="cb6-3"><a href="#cb6-3"></a><span class="co">#&gt;       post.mean post.sd    q2.5     q50   q97.5 f0  n.eff  Rhat</span></span>
<span id="cb6-4"><a href="#cb6-4"></a><span class="co">#&gt; D         0.234   0.121   0.040   0.221   0.453  1 33.817 1.121</span></span>
<span id="cb6-5"><a href="#cb6-5"></a><span class="co">#&gt; N       250.204 129.023  43.000 237.000 485.000  1 33.817 1.121</span></span>
<span id="cb6-6"><a href="#cb6-6"></a><span class="co">#&gt; lam0      0.385   0.238   0.065   0.357   0.906  1 68.708 1.020</span></span>
<span id="cb6-7"><a href="#cb6-7"></a><span class="co">#&gt; psiu      0.500   0.258   0.086   0.475   0.968  1 33.594 1.119</span></span>
<span id="cb6-8"><a href="#cb6-8"></a><span class="co">#&gt; sigma   344.133 202.596 146.564 270.782 932.274  1 31.582 1.282</span></span></code></pre></div>
<br>
<p>
Although we are able to produce estimates, they are not reliable due to the lack of convergence and huge uncertainty. This will be the case for many spatial count modeling problems and thus, it is common to include prior information or combine marked and unmarked individuals into a spatial mark-resight analysis (the topic of vignette 3). Here, we’ll test out the effect of bringing in prior information on the scaling parameter; this could occur if we had estimates of <code>sigma</code> from a previous study or another data source. We’ll first need to use a moment matching function (e.g., normal to gamma moments) from the ‘modeltools’ package (add citation) called <code>estGammaParam()</code>. The gamma distribution is appropriate since it has support from 0 to infinity. For this example, we’ll just grab some estimates of posterior standard error from part 3 of vignette 1. We know the ‘true’ simulated value of sigma is 300.
</p>
<p><br></p>
</div>
<div id="adding-prior-information-on-the-scaling-and-encounter-rate-parameters" class="section level3">
<h3>(4) Adding prior information on the scaling and encounter rate parameters</h3>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1"></a><span class="co"># get from Github and load</span></span>
<span id="cb7-2"><a href="#cb7-2"></a><span class="co">#install_github(&quot;austinnam/modeltools&quot;,force=TRUE) </span></span>
<span id="cb7-3"><a href="#cb7-3"></a><span class="kw">library</span>(modeltools)</span>
<span id="cb7-4"><a href="#cb7-4"></a></span>
<span id="cb7-5"><a href="#cb7-5"></a><span class="co"># get &#39;alpha&#39; and &#39;beta&#39; parameters of Gamma distribution</span></span>
<span id="cb7-6"><a href="#cb7-6"></a>gparam =<span class="st"> </span><span class="kw">estGammaParam</span>(<span class="dt">mu =</span> mysigma, <span class="dt">sigma =</span> <span class="dv">30</span>)</span>
<span id="cb7-7"><a href="#cb7-7"></a></span>
<span id="cb7-8"><a href="#cb7-8"></a><span class="co"># view prior distribution for sigma (scaling parameter)</span></span>
<span id="cb7-9"><a href="#cb7-9"></a><span class="kw">hist</span>(<span class="kw">rgamma</span>(<span class="dv">100000</span>,<span class="dt">shape=</span>gparam<span class="op">$</span>alpha,<span class="dt">rate=</span><span class="dv">1</span><span class="op">/</span>gparam<span class="op">$</span>beta),<span class="dt">main=</span><span class="st">&quot;&quot;</span>,<span class="dt">xlab=</span><span class="st">&quot;Gamma prior&quot;</span>)</span></code></pre></div>
<p align="center">
<img src="../man/figures/vignette_02/Fig4.png" style="width:70%" />
</p>
<br>
<p>
To add our prior information, we’ll use <code>customize_model()</code> to edit our previously created model. Then, we’ll rerun the model using <code>run_classic</code>.
</p>
<p><br></p>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1"></a><span class="co"># define new code to replace line 3 in &#39;sc_model&#39;</span></span>
<span id="cb8-2"><a href="#cb8-2"></a><span class="kw">library</span>(nimble)</span>
<span id="cb8-3"><a href="#cb8-3"></a>new_prior =<span class="st"> </span><span class="kw">nimbleCode</span>({</span>
<span id="cb8-4"><a href="#cb8-4"></a>   sigma <span class="op">~</span><span class="st"> </span><span class="kw">dgamma</span>(alpha, <span class="dv">1</span><span class="op">/</span>beta) <span class="co"># note that dgamma takes rate (1/beta)</span></span>
<span id="cb8-5"><a href="#cb8-5"></a>})</span>
<span id="cb8-6"><a href="#cb8-6"></a></span>
<span id="cb8-7"><a href="#cb8-7"></a><span class="co"># delete old prior on line 3 and replace with new prior </span></span>
<span id="cb8-8"><a href="#cb8-8"></a>sc_model_inf =<span class="st"> </span><span class="kw">customize_model</span>(<span class="dt">model =</span> sc_model, <span class="dt">append_code =</span> new_prior,</span>
<span id="cb8-9"><a href="#cb8-9"></a>                               <span class="dt">append_line=</span><span class="dv">3</span>,<span class="dt">remove_line=</span><span class="dv">3</span>)</span>
<span id="cb8-10"><a href="#cb8-10"></a></span>
<span id="cb8-11"><a href="#cb8-11"></a><span class="co"># inspect model (not run)</span></span>
<span id="cb8-12"><a href="#cb8-12"></a><span class="co"># sc_model_inf</span></span>
<span id="cb8-13"><a href="#cb8-13"></a></span>
<span id="cb8-14"><a href="#cb8-14"></a><span class="co"># add &#39;alpha&#39; and &#39;beta&#39; to list of constants</span></span>
<span id="cb8-15"><a href="#cb8-15"></a>constants<span class="op">$</span>alpha =<span class="st"> </span>gparam<span class="op">$</span>alpha</span>
<span id="cb8-16"><a href="#cb8-16"></a>constants<span class="op">$</span>beta =<span class="st"> </span>gparam<span class="op">$</span>beta</span>
<span id="cb8-17"><a href="#cb8-17"></a></span>
<span id="cb8-18"><a href="#cb8-18"></a><span class="co"># run model (note we set s_alias to &quot;su&quot; for spatial count model)</span></span>
<span id="cb8-19"><a href="#cb8-19"></a><span class="kw">library</span>(tictoc)</span>
<span id="cb8-20"><a href="#cb8-20"></a><span class="kw">tic</span>() <span class="co"># track time elapsed</span></span>
<span id="cb8-21"><a href="#cb8-21"></a>out =<span class="st"> </span><span class="kw">run_classic</span>(<span class="dt">model =</span> sc_model_inf, <span class="dt">data=</span>data, <span class="dt">constants=</span>constants,</span>
<span id="cb8-22"><a href="#cb8-22"></a><span class="dt">inits=</span>inits, <span class="dt">params =</span> params,<span class="dt">niter =</span> <span class="dv">10000</span>, <span class="dt">nburnin=</span><span class="dv">1000</span>, <span class="dt">thin=</span><span class="dv">1</span>, <span class="dt">nchains=</span><span class="dv">2</span>, <span class="dt">parallel=</span><span class="ot">TRUE</span>,</span>
<span id="cb8-23"><a href="#cb8-23"></a><span class="dt">RNGseed =</span> <span class="dv">500</span>,<span class="dt">s_alias=</span><span class="st">&quot;su&quot;</span>)</span>
<span id="cb8-24"><a href="#cb8-24"></a><span class="kw">toc</span>()</span>
<span id="cb8-25"><a href="#cb8-25"></a><span class="co">#&gt; 836.56 sec elapsed</span></span>
<span id="cb8-26"><a href="#cb8-26"></a></span>
<span id="cb8-27"><a href="#cb8-27"></a><span class="co"># summarize output</span></span>
<span id="cb8-28"><a href="#cb8-28"></a>samples =<span class="st"> </span><span class="kw">do.call</span>(rbind, out)</span>
<span id="cb8-29"><a href="#cb8-29"></a><span class="kw">par</span>(<span class="dt">mfrow=</span><span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">1</span>))</span>
<span id="cb8-30"><a href="#cb8-30"></a><span class="kw">hist</span>(samples[,<span class="kw">which</span>(<span class="kw">dimnames</span>(out[[<span class="dv">1</span>]])[[<span class="dv">2</span>]]<span class="op">==</span><span class="st">&quot;N&quot;</span>)], <span class="dt">xlab =</span> <span class="st">&quot;Abundance&quot;</span>, <span class="dt">xlim =</span> <span class="kw">c</span>(<span class="dv">0</span>,<span class="dv">500</span>), <span class="dt">main=</span><span class="st">&quot;&quot;</span>)</span>
<span id="cb8-31"><a href="#cb8-31"></a><span class="kw">abline</span>(<span class="dt">v=</span><span class="dv">200</span>, <span class="dt">col=</span><span class="st">&quot;red&quot;</span>) <span class="co"># add line for simulated abundance</span></span></code></pre></div>
<p align="center">
<img src="../man/figures/vignette_02/Fig5.png" style="width:70%" />
</p>
<p><br></p>
<p>
Again, we see that convergence is not great despite having prior information on sigma, but it’s an improvement and the median estimate of N is close to the simulated value of 200. The uncertainty both the encounter rate <code>lam0</code> and the augmentation parameter <code>psiu</code> is still huge, which translates into large uncertainty in abundance. We can try adding prior information about the encounter rate as well and see how this affects the estimates. We’ll use a similar strategy as we did for the scaling parameter ‘sigma’.
</p>
<p><br></p>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1"></a><span class="co"># define new code to replace line 3 in &#39;sc_model&#39;</span></span>
<span id="cb9-2"><a href="#cb9-2"></a>new_prior =<span class="st"> </span><span class="kw">nimbleCode</span>({</span>
<span id="cb9-3"><a href="#cb9-3"></a>   lam0 <span class="op">~</span><span class="st"> </span><span class="kw">dgamma</span>(alpha_lam0, <span class="dv">1</span><span class="op">/</span>beta_lam0) <span class="co"># note that dgamma takes rate (1/beta)</span></span>
<span id="cb9-4"><a href="#cb9-4"></a>})</span>
<span id="cb9-5"><a href="#cb9-5"></a></span>
<span id="cb9-6"><a href="#cb9-6"></a><span class="co"># delete old prior on line 3 and replace with new prior </span></span>
<span id="cb9-7"><a href="#cb9-7"></a>sc_model_inf2 =<span class="st"> </span><span class="kw">customize_model</span>(<span class="dt">model =</span> sc_model_inf, <span class="dt">append_code =</span> new_prior,</span>
<span id="cb9-8"><a href="#cb9-8"></a>                               <span class="dt">append_line=</span><span class="dv">2</span>,<span class="dt">remove_line=</span><span class="dv">2</span>)</span>
<span id="cb9-9"><a href="#cb9-9"></a></span>
<span id="cb9-10"><a href="#cb9-10"></a><span class="co"># inspect model (not run)</span></span>
<span id="cb9-11"><a href="#cb9-11"></a><span class="co"># sc_model_inf2</span></span>
<span id="cb9-12"><a href="#cb9-12"></a></span>
<span id="cb9-13"><a href="#cb9-13"></a><span class="co"># get &#39;alpha&#39; and &#39;beta&#39; parameters of Gamma distribution</span></span>
<span id="cb9-14"><a href="#cb9-14"></a>lam0_param =<span class="st"> </span><span class="kw">estGammaParam</span>(<span class="dt">mu =</span> <span class="fl">0.30</span>, <span class="dt">sigma =</span> <span class="fl">0.03</span>)</span>
<span id="cb9-15"><a href="#cb9-15"></a></span>
<span id="cb9-16"><a href="#cb9-16"></a><span class="co"># add &#39;alpha&#39; and &#39;beta&#39; to list of constants</span></span>
<span id="cb9-17"><a href="#cb9-17"></a>constants<span class="op">$</span>alpha_lam0 =<span class="st"> </span>lam0_param<span class="op">$</span>alpha</span>
<span id="cb9-18"><a href="#cb9-18"></a>constants<span class="op">$</span>beta_lam0 =<span class="st"> </span>lam0_param<span class="op">$</span>beta</span>
<span id="cb9-19"><a href="#cb9-19"></a></span>
<span id="cb9-20"><a href="#cb9-20"></a><span class="co"># run model (note we set s_alias to &quot;su&quot; for spatial count model)</span></span>
<span id="cb9-21"><a href="#cb9-21"></a><span class="kw">library</span>(tictoc)</span>
<span id="cb9-22"><a href="#cb9-22"></a><span class="kw">tic</span>() <span class="co"># track time elapsed</span></span>
<span id="cb9-23"><a href="#cb9-23"></a>out =<span class="st"> </span><span class="kw">run_classic</span>(<span class="dt">model =</span> sc_model_inf2, <span class="dt">data=</span>data, <span class="dt">constants=</span>constants,</span>
<span id="cb9-24"><a href="#cb9-24"></a><span class="dt">inits=</span>inits, <span class="dt">params =</span> params,<span class="dt">niter =</span> <span class="dv">10000</span>, <span class="dt">nburnin=</span><span class="dv">1000</span>, <span class="dt">thin=</span><span class="dv">1</span>, <span class="dt">nchains=</span><span class="dv">2</span>, <span class="dt">parallel=</span><span class="ot">TRUE</span>,</span>
<span id="cb9-25"><a href="#cb9-25"></a><span class="dt">RNGseed =</span> <span class="dv">500</span>,<span class="dt">s_alias=</span><span class="st">&quot;su&quot;</span>)</span>
<span id="cb9-26"><a href="#cb9-26"></a><span class="kw">toc</span>()</span>
<span id="cb9-27"><a href="#cb9-27"></a><span class="co">#&gt; 1193.95 sec elapsed</span></span>
<span id="cb9-28"><a href="#cb9-28"></a></span>
<span id="cb9-29"><a href="#cb9-29"></a><span class="co"># summarize output (exclude &quot;su&quot; and &quot;zu&quot; from table and make posterior/trace plots)</span></span>
<span id="cb9-30"><a href="#cb9-30"></a><span class="kw">nimSummary</span>(out, <span class="dt">exclude =</span> <span class="kw">c</span>(<span class="st">&quot;su&quot;</span>,<span class="st">&quot;zu&quot;</span>), <span class="dt">trace=</span><span class="ot">TRUE</span>, <span class="dt">plot_all=</span><span class="ot">FALSE</span>)</span>
<span id="cb9-31"><a href="#cb9-31"></a><span class="co">#&gt;       post.mean post.sd    q2.5     q50   q97.5 f0    n.eff  Rhat</span></span>
<span id="cb9-32"><a href="#cb9-32"></a><span class="co">#&gt; D         0.223   0.053   0.137   0.219   0.343  1  275.831 1.001</span></span>
<span id="cb9-33"><a href="#cb9-33"></a><span class="co">#&gt; N       238.946  56.449 147.000 234.000 367.000  1  275.831 1.001</span></span>
<span id="cb9-34"><a href="#cb9-34"></a><span class="co">#&gt; lam0      0.298   0.029   0.244   0.297   0.358  1 1374.996 1.000</span></span>
<span id="cb9-35"><a href="#cb9-35"></a><span class="co">#&gt; psi       0.478   0.114   0.288   0.468   0.737  1  287.766 1.001</span></span>
<span id="cb9-36"><a href="#cb9-36"></a><span class="co">#&gt; sigma   287.307  28.393 234.682 286.116 346.612  1  301.998 1.013</span></span></code></pre></div>
<p align="center">
<img src="../man/figures/vignette_02/Fig6.png" style="width:70%" />
</p>
<br>
<p>
<p>We can see that convergence is improved by a decent margin with the addition of prior information but a considerable amount of uncertainty still exists in abundance <code>N</code> which has around a 23.6% (56.4/239.0*100) coefficient of variation (CV). The estimate of abundance is about 239 individuals, which is biased slightly highly high. Regardless, this example shows that without prior information (or sharing of parameters with other data sources such as in a mark-resight approach), the spatial count model struggles to make inference to abundance on its own. We also note a substantial increase in model run time up to 20 minutes on our machine (albeit on a somewhat slow laptop).</p>
Finally, we make a realized density plot of the MCMC samples using <code>realized_density()</code>. In this function we make use of the list of grid and extent we created earlier called <code>Grid</code> as well as our saved coordinates reference system (<code>mycrs</code>). In this example, we use the ‘raster’ package to make a simple plot of the output. We can see that the habitat mask has resulted in some cells having <code>NA</code> values where the habitat was unsuitable.
</p>
<p><br></p>
<div class="sourceCode" id="cb10"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1"></a><span class="co"># make realized density plot (need to specify s_alias and z_alias)</span></span>
<span id="cb10-2"><a href="#cb10-2"></a>r =<span class="st"> </span><span class="kw">realized_density</span>(<span class="dt">samples =</span> out, <span class="dt">grid =</span> Grid<span class="op">$</span>grid, <span class="dt">crs_ =</span> mycrs, <span class="dt">site =</span> <span class="ot">NULL</span>, </span>
<span id="cb10-3"><a href="#cb10-3"></a>                     <span class="dt">hab_mask =</span> hab_mask, <span class="dt">s_alias =</span> <span class="st">&quot;su&quot;</span>, <span class="dt">z_alias =</span> <span class="st">&quot;zu&quot;</span>)       </span>
<span id="cb10-4"><a href="#cb10-4"></a>      </span>
<span id="cb10-5"><a href="#cb10-5"></a><span class="co"># load virdiis color palette and raster libraries      </span></span>
<span id="cb10-6"><a href="#cb10-6"></a><span class="kw">library</span>(viridis)</span>
<span id="cb10-7"><a href="#cb10-7"></a><span class="kw">library</span>(raster)</span>
<span id="cb10-8"><a href="#cb10-8"></a></span>
<span id="cb10-9"><a href="#cb10-9"></a><span class="co"># make simple raster plot</span></span>
<span id="cb10-10"><a href="#cb10-10"></a><span class="kw">plot</span>(r, <span class="dt">col=</span><span class="kw">viridis</span>(<span class="dv">100</span>),</span>
<span id="cb10-11"><a href="#cb10-11"></a>     <span class="dt">main=</span><span class="kw">expression</span>(<span class="st">&quot;Realized density (activity centers/100 m&quot;</span><span class="op">^</span><span class="dv">2</span><span class="op">*</span><span class="st">&quot;)&quot;</span>),</span>
<span id="cb10-12"><a href="#cb10-12"></a>     <span class="dt">ylab=</span><span class="st">&quot;Northing&quot;</span>,<span class="dt">xlab=</span><span class="st">&quot;Easting&quot;</span>)</span></code></pre></div>
<p align="center">
<img src="../man/figures/vignette_02/Fig7.png" style="width:70%" />
</p>
<p><br></p>
<p>
<p>We demonstrated the ability of functions such as <code>customize_model()</code> to efficiently edit model code without have to copy and paste a large amount of text. We used ‘sim_classic()’ to first generate a 3-dimensional encounter history data set for marked individuals, and then we summed over traps and occasions to arrive at a spatial count data set (<code>n[j,k]</code>).</p>
<p>As a final step example in this tutorial, we demonstrate the ability of the ‘localSCR’ package to aid in analyzing a spatial count model when we have clustered trap arrays (i.e., trap arrays that are spaced out far enough that individuals can only be detected on one array). The workflow will be similar to part 3 in our example, except that we’ll need to create an indexing to allocate augmented individuals to the correct trap array. For this, we’ll create the objects <code>site_indexL</code> and <code>site_indexU</code> and we will see this index in the model as <code>site_indexL[g]:site_indexU[g]</code>. We’ll also use the same informative priors the we developed above in part 4.</p>
</p>
</div>
<div id="workflow-for-spatial-count-model-with-poisson-encounter-distribution-and-habitat-mask-using-a-3d-trap-array-or-clustered-trap" class="section level3">
<h3>(5) Workflow for spatial count model with Poisson encounter distribution and habitat mask using a 3D trap array or clustered trap</h3>
<div class="sourceCode" id="cb11"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1"></a><span class="co"># simulate a single trap array with random positional noise</span></span>
<span id="cb11-2"><a href="#cb11-2"></a>x &lt;-<span class="st"> </span><span class="kw">seq</span>(<span class="op">-</span><span class="dv">800</span>, <span class="dv">800</span>, <span class="dt">length.out =</span> <span class="dv">5</span>)</span>
<span id="cb11-3"><a href="#cb11-3"></a>y &lt;-<span class="st"> </span><span class="kw">seq</span>(<span class="op">-</span><span class="dv">800</span>, <span class="dv">800</span>, <span class="dt">length.out =</span> <span class="dv">5</span>)</span>
<span id="cb11-4"><a href="#cb11-4"></a>traps &lt;-<span class="st"> </span><span class="kw">as.matrix</span>(<span class="kw">expand.grid</span>(<span class="dt">x =</span> x, <span class="dt">y =</span> y))</span>
<span id="cb11-5"><a href="#cb11-5"></a><span class="kw">set.seed</span>(<span class="dv">200</span>)</span>
<span id="cb11-6"><a href="#cb11-6"></a>traps &lt;-<span class="st"> </span>traps <span class="op">+</span><span class="st"> </span><span class="kw">runif</span>(<span class="kw">prod</span>(<span class="kw">dim</span>(traps)),<span class="op">-</span><span class="dv">20</span>,<span class="dv">20</span>) </span>
<span id="cb11-7"><a href="#cb11-7"></a></span>
<span id="cb11-8"><a href="#cb11-8"></a>mysigma =<span class="st"> </span><span class="dv">300</span> <span class="co"># simulate single scaling parameter</span></span>
<span id="cb11-9"><a href="#cb11-9"></a>mycrs =<span class="st"> </span><span class="dv">32608</span> <span class="co"># EPSG for WGS 84 / UTM zone 8N</span></span>
<span id="cb11-10"><a href="#cb11-10"></a>pixelWidth =<span class="st"> </span><span class="dv">100</span> <span class="co"># store pixelWidth</span></span>
<span id="cb11-11"><a href="#cb11-11"></a></span>
<span id="cb11-12"><a href="#cb11-12"></a><span class="co"># create an array of traps, as an approach where individuals will only be detected </span></span>
<span id="cb11-13"><a href="#cb11-13"></a><span class="co"># at one of the trap arrays (e.g., Furnas et al. 2018)</span></span>
<span id="cb11-14"><a href="#cb11-14"></a>Xarray =<span class="st"> </span><span class="kw">array</span>(<span class="ot">NA</span>, <span class="dt">dim=</span><span class="kw">c</span>(<span class="kw">nrow</span>(traps),<span class="dv">2</span>,<span class="dv">2</span>))</span>
<span id="cb11-15"><a href="#cb11-15"></a>Xarray[,,<span class="dv">1</span>]=traps</span>
<span id="cb11-16"><a href="#cb11-16"></a>Xarray[,,<span class="dv">2</span>]=traps<span class="op">+</span><span class="dv">4000</span> <span class="co"># shift trapping grid to new locations</span></span>
<span id="cb11-17"><a href="#cb11-17"></a></span>
<span id="cb11-18"><a href="#cb11-18"></a><span class="co"># create grid and extent for 3D trap array</span></span>
<span id="cb11-19"><a href="#cb11-19"></a>GridX =<span class="st"> </span><span class="kw">grid_classic</span>(<span class="dt">X =</span> Xarray, <span class="dt">crs_ =</span> mycrs, <span class="dt">buff =</span> <span class="dv">3</span><span class="op">*</span><span class="kw">max</span>(mysigma), <span class="dt">res =</span> <span class="dv">100</span>)</span>
<span id="cb11-20"><a href="#cb11-20"></a></span>
<span id="cb11-21"><a href="#cb11-21"></a><span class="co"># create polygon to use as a mask</span></span>
<span id="cb11-22"><a href="#cb11-22"></a><span class="kw">library</span>(sf)</span>
<span id="cb11-23"><a href="#cb11-23"></a>poly =<span class="st"> </span><span class="kw">st_sfc</span>(<span class="kw">st_polygon</span>(<span class="dt">x=</span><span class="kw">list</span>(<span class="kw">matrix</span>(<span class="kw">c</span>(<span class="op">-</span><span class="dv">1660</span>,<span class="op">-</span><span class="dv">1900</span>,<span class="dv">5730</span>,<span class="op">-</span><span class="dv">1050</span>,<span class="dv">5470</span>,</span>
<span id="cb11-24"><a href="#cb11-24"></a><span class="dv">5650</span>,<span class="dv">0</span>,<span class="dv">6050</span>,<span class="op">-</span><span class="dv">1800</span>,<span class="dv">5700</span>,<span class="op">-</span><span class="dv">1660</span>,<span class="op">-</span><span class="dv">1900</span>),<span class="dt">ncol=</span><span class="dv">2</span>, <span class="dt">byrow=</span><span class="ot">TRUE</span>))), <span class="dt">crs =</span>  mycrs)</span>
<span id="cb11-25"><a href="#cb11-25"></a></span>
<span id="cb11-26"><a href="#cb11-26"></a><span class="co"># make ggplot</span></span>
<span id="cb11-27"><a href="#cb11-27"></a><span class="kw">ggplot</span>() <span class="op">+</span><span class="st"> </span><span class="kw">geom_point</span>(<span class="dt">data=</span><span class="kw">as.data.frame</span>(GridX<span class="op">$</span>grid[,,<span class="dv">1</span>]),<span class="kw">aes</span>(<span class="dt">x=</span>V1,<span class="dt">y=</span>V2),</span>
<span id="cb11-28"><a href="#cb11-28"></a>                      <span class="dt">color=</span><span class="st">&quot;grey60&quot;</span>,<span class="dt">size=</span><span class="fl">1.25</span>) <span class="op">+</span></span>
<span id="cb11-29"><a href="#cb11-29"></a><span class="st">    </span><span class="kw">geom_point</span>(<span class="dt">data=</span><span class="kw">as.data.frame</span>(Xarray[,,<span class="dv">1</span>]),<span class="kw">aes</span>(<span class="dt">x=</span>V1,<span class="dt">y=</span>V2),<span class="dt">color=</span><span class="st">&quot;blue&quot;</span>,<span class="dt">size=</span><span class="dv">2</span>) <span class="op">+</span></span>
<span id="cb11-30"><a href="#cb11-30"></a><span class="st">    </span><span class="kw">geom_point</span>(<span class="dt">data=</span><span class="kw">as.data.frame</span>(GridX<span class="op">$</span>grid[,,<span class="dv">2</span>]),<span class="kw">aes</span>(<span class="dt">x=</span>V1,<span class="dt">y=</span>V2),<span class="dt">color=</span><span class="st">&quot;grey60&quot;</span>,</span>
<span id="cb11-31"><a href="#cb11-31"></a>               <span class="dt">size=</span><span class="fl">1.25</span>) <span class="op">+</span></span>
<span id="cb11-32"><a href="#cb11-32"></a><span class="st">    </span><span class="kw">geom_point</span>(<span class="dt">data=</span><span class="kw">as.data.frame</span>(Xarray[,,<span class="dv">2</span>]),<span class="kw">aes</span>(<span class="dt">x=</span>V1,<span class="dt">y=</span>V2),<span class="dt">color=</span><span class="st">&quot;blue&quot;</span>,<span class="dt">size=</span><span class="dv">2</span>) <span class="op">+</span></span>
<span id="cb11-33"><a href="#cb11-33"></a><span class="st">    </span><span class="kw">geom_sf</span>(<span class="dt">data=</span>poly, <span class="dt">fill =</span> <span class="ot">NA</span>) <span class="op">+</span><span class="st"> </span><span class="kw">coord_sf</span>(<span class="dt">datum=</span><span class="kw">st_crs</span>(mycrs)) <span class="op">+</span></span>
<span id="cb11-34"><a href="#cb11-34"></a><span class="st">    </span><span class="kw">theme_classic</span>() <span class="op">+</span><span class="st"> </span><span class="kw">ylab</span>(<span class="st">&quot;Northing&quot;</span>) <span class="op">+</span><span class="st"> </span><span class="kw">xlab</span>(<span class="st">&quot;Easting&quot;</span>) <span class="op">+</span></span>
<span id="cb11-35"><a href="#cb11-35"></a><span class="st">    </span><span class="kw">scale_x_continuous</span>(<span class="dt">limits=</span><span class="kw">c</span>(<span class="op">-</span><span class="dv">2000</span>,<span class="dv">6000</span>)) <span class="op">+</span></span>
<span id="cb11-36"><a href="#cb11-36"></a><span class="st">    </span><span class="kw">scale_y_continuous</span>(<span class="dt">limits=</span><span class="kw">c</span>(<span class="op">-</span><span class="dv">2000</span>,<span class="dv">6000</span>)) <span class="op">+</span><span class="st"> </span></span>
<span id="cb11-37"><a href="#cb11-37"></a><span class="st">    </span><span class="kw">theme</span>(<span class="dt">axis.text =</span> <span class="kw">element_text</span>(<span class="dt">size=</span><span class="dv">12</span>),<span class="dt">axis.title =</span> <span class="kw">element_text</span>(<span class="dt">size=</span><span class="dv">16</span>))</span></code></pre></div>
<p align="center">
<img src="../man/figures/vignette_02/Fig8.png" style="width:70%" />
</p>
<br>
<p>
In the figure we can see our two spatially separated trapping grids and that the polygon overlaps some of the gridded area. The area outside the polygon will be considered unsuitable when the habitat matrix is created. Note that the <code>site</code> variable will be only as long as the simulated population size (here, 200) and thus, we will need to augment the variable to have the length equal to the total augmented population size (i.e., <code>m = 400</code>). Otherwise the workflow is very similar to the previous one.
</p>
<p><br></p>
<div class="sourceCode" id="cb12"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1"></a><span class="co"># get 3D habitat mask array for 3D grid</span></span>
<span id="cb12-2"><a href="#cb12-2"></a>hab_mask =<span class="st"> </span><span class="kw">mask_polygon</span>(<span class="dt">poly =</span> poly, <span class="dt">grid =</span> GridX<span class="op">$</span>grid, <span class="dt">crs_ =</span> mycrs, <span class="dt">prev_mask =</span> <span class="ot">NULL</span>)</span>
<span id="cb12-3"><a href="#cb12-3"></a></span>
<span id="cb12-4"><a href="#cb12-4"></a><span class="co"># simulate data for uniform state-space and habitat mask (N is simulated abundance)</span></span>
<span id="cb12-5"><a href="#cb12-5"></a>data4d =<span class="st"> </span><span class="kw">sim_classic</span>(<span class="dt">X =</span> Xarray, <span class="dt">ext =</span> GridX<span class="op">$</span>ext, <span class="dt">crs_ =</span> mycrs, </span>
<span id="cb12-6"><a href="#cb12-6"></a>                     <span class="dt">sigma_ =</span> mysigma,<span class="dt">prop_sex =</span> <span class="dv">1</span>,<span class="dt">N =</span> <span class="dv">200</span>, <span class="dt">K =</span> <span class="dv">4</span>,  </span>
<span id="cb12-7"><a href="#cb12-7"></a>                   <span class="dt">base_encounter =</span> <span class="fl">0.3</span>, <span class="dt">enc_dist =</span> <span class="st">&quot;poisson&quot;</span>,</span>
<span id="cb12-8"><a href="#cb12-8"></a>                   <span class="dt">hab_mask =</span> hab_mask, <span class="dt">setSeed =</span> <span class="dv">100</span>)</span>
<span id="cb12-9"><a href="#cb12-9"></a></span>
<span id="cb12-10"><a href="#cb12-10"></a><span class="co"># organize by site and bind into an array</span></span>
<span id="cb12-11"><a href="#cb12-11"></a><span class="kw">library</span>(abind) <span class="co"># load abind package</span></span>
<span id="cb12-12"><a href="#cb12-12"></a>y =<span class="st"> </span><span class="kw">abind</span>(data4d<span class="op">$</span>y[<span class="kw">which</span>(data4d<span class="op">$</span>site<span class="op">==</span><span class="dv">1</span>),,],</span>
<span id="cb12-13"><a href="#cb12-13"></a>          data4d<span class="op">$</span>y[<span class="kw">which</span>(data4d<span class="op">$</span>site<span class="op">==</span><span class="dv">2</span>),,], <span class="dt">along =</span> <span class="dv">4</span>)</span>
<span id="cb12-14"><a href="#cb12-14"></a></span>
<span id="cb12-15"><a href="#cb12-15"></a><span class="co"># total augmented population size </span></span>
<span id="cb12-16"><a href="#cb12-16"></a>m =<span class="st"> </span><span class="dv">400</span></span>
<span id="cb12-17"><a href="#cb12-17"></a></span>
<span id="cb12-18"><a href="#cb12-18"></a><span class="co"># augment site identifier</span></span>
<span id="cb12-19"><a href="#cb12-19"></a>site =<span class="st"> </span><span class="kw">c</span>(<span class="kw">rep</span>(<span class="dv">1</span>,<span class="dv">200</span>),<span class="kw">rep</span>(<span class="dv">2</span>,<span class="dv">200</span>))</span>
<span id="cb12-20"><a href="#cb12-20"></a></span>
<span id="cb12-21"><a href="#cb12-21"></a><span class="co"># get initial activity center starting values </span></span>
<span id="cb12-22"><a href="#cb12-22"></a>s.st4d =<span class="st"> </span><span class="kw">initialize_classic</span>(<span class="dt">y=</span><span class="ot">NULL</span>, <span class="dt">M=</span>m, <span class="dt">X=</span>Xarray, <span class="dt">ext =</span> GridX<span class="op">$</span>ext, </span>
<span id="cb12-23"><a href="#cb12-23"></a>                      <span class="dt">site =</span> site, <span class="dt">hab_mask =</span> hab_mask,<span class="dt">all_random =</span> <span class="ot">TRUE</span>)</span>
<span id="cb12-24"><a href="#cb12-24"></a></span>
<span id="cb12-25"><a href="#cb12-25"></a><span class="co"># rescale inputs</span></span>
<span id="cb12-26"><a href="#cb12-26"></a>rescale_list =<span class="st"> </span><span class="kw">rescale_classic</span>(<span class="dt">X =</span> Xarray, <span class="dt">ext =</span> GridX<span class="op">$</span>ext, <span class="dt">s.st =</span> s.st4d, </span>
<span id="cb12-27"><a href="#cb12-27"></a>                               <span class="dt">site =</span> site, <span class="dt">hab_mask =</span> hab_mask)</span>
<span id="cb12-28"><a href="#cb12-28"></a></span>
<span id="cb12-29"><a href="#cb12-29"></a><span class="co"># store rescaled extent and convert to matrix</span></span>
<span id="cb12-30"><a href="#cb12-30"></a>ext =<span class="st"> </span><span class="kw">do.call</span>(rbind, <span class="kw">lapply</span>(rescale_list<span class="op">$</span>ext, as.vector))</span>
<span id="cb12-31"><a href="#cb12-31"></a></span>
<span id="cb12-32"><a href="#cb12-32"></a><span class="co"># Prepare data by summing over traps and occasions and add to list</span></span>
<span id="cb12-33"><a href="#cb12-33"></a>data =<span class="st"> </span><span class="kw">list</span>(<span class="dt">n =</span> <span class="kw">apply</span>(y, <span class="kw">c</span>(<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>), sum),<span class="dt">x_lower =</span> ext[,<span class="dv">1</span>],</span>
<span id="cb12-34"><a href="#cb12-34"></a>            <span class="dt">x_upper =</span> ext[,<span class="dv">2</span>],<span class="dt">y_lower =</span> ext[,<span class="dv">3</span>]</span>
<span id="cb12-35"><a href="#cb12-35"></a>            ,<span class="dt">y_upper =</span> ext[,<span class="dv">4</span>],<span class="dt">X =</span> rescale_list<span class="op">$</span>X)</span>
<span id="cb12-36"><a href="#cb12-36"></a></span>
<span id="cb12-37"><a href="#cb12-37"></a><span class="co"># add hab_mask, proportion of available habitat, and OK for habitat check</span></span>
<span id="cb12-38"><a href="#cb12-38"></a>data<span class="op">$</span>hab_mask =<span class="st"> </span>hab_mask</span>
<span id="cb12-39"><a href="#cb12-39"></a><span class="co"># need to adjust proportion of habitat available</span></span>
<span id="cb12-40"><a href="#cb12-40"></a>data<span class="op">$</span>prop.habitat=<span class="kw">apply</span>(hab_mask,<span class="dv">3</span>,mean) </span>
<span id="cb12-41"><a href="#cb12-41"></a>data<span class="op">$</span>OK =<span class="st"> </span><span class="kw">rep</span>(<span class="dv">1</span>,constants<span class="op">$</span>m)</span>
<span id="cb12-42"><a href="#cb12-42"></a></span>
<span id="cb12-43"><a href="#cb12-43"></a><span class="co"># prepare constants (note get density in activity center/100 m2)</span></span>
<span id="cb12-44"><a href="#cb12-44"></a>constants =<span class="st"> </span><span class="kw">list</span>(<span class="dt">m =</span> m,<span class="dt">J=</span><span class="kw">dim</span>(data4d<span class="op">$</span>y)[<span class="dv">2</span>],</span>
<span id="cb12-45"><a href="#cb12-45"></a> <span class="dt">K=</span><span class="kw">dim</span>(data4d<span class="op">$</span>y)[<span class="dv">3</span>], <span class="dt">sigma_upper =</span> <span class="dv">1000</span>, <span class="dt">A =</span> (<span class="kw">sum</span>(hab_mask)<span class="op">*</span>(pixelWidth<span class="op">/</span><span class="dv">100</span>)<span class="op">^</span><span class="dv">2</span>),</span>
<span id="cb12-46"><a href="#cb12-46"></a><span class="dt">pixelWidth=</span>pixelWidth,<span class="dt">nSites=</span><span class="kw">dim</span>(Xarray)[<span class="dv">3</span>],<span class="dt">site =</span> site)</span>
<span id="cb12-47"><a href="#cb12-47"></a></span>
<span id="cb12-48"><a href="#cb12-48"></a><span class="co"># add indexes for sites and individuals</span></span>
<span id="cb12-49"><a href="#cb12-49"></a>constants<span class="op">$</span>site_indexL =<span class="st"> </span><span class="kw">seq</span>(<span class="dv">1</span>,m,<span class="dv">200</span>)</span>
<span id="cb12-50"><a href="#cb12-50"></a>constants<span class="op">$</span>site_indexU =<span class="st"> </span><span class="kw">seq</span>(<span class="dv">200</span>,m,<span class="dv">200</span>)</span>
<span id="cb12-51"><a href="#cb12-51"></a>          </span>
<span id="cb12-52"><a href="#cb12-52"></a><span class="co"># priors for sigma: &#39;alpha&#39; and &#39;beta&#39; </span></span>
<span id="cb12-53"><a href="#cb12-53"></a>constants<span class="op">$</span>alpha =<span class="st"> </span>gparam<span class="op">$</span>alpha</span>
<span id="cb12-54"><a href="#cb12-54"></a>constants<span class="op">$</span>beta =<span class="st"> </span>gparam<span class="op">$</span>beta</span>
<span id="cb12-55"><a href="#cb12-55"></a></span>
<span id="cb12-56"><a href="#cb12-56"></a><span class="co"># priors for lam0: &#39;alpha&#39; and &#39;beta&#39; </span></span>
<span id="cb12-57"><a href="#cb12-57"></a>constants<span class="op">$</span>alpha_lam0 =<span class="st"> </span>lam0_param<span class="op">$</span>alpha</span>
<span id="cb12-58"><a href="#cb12-58"></a>constants<span class="op">$</span>beta_lam0 =<span class="st"> </span>lam0_param<span class="op">$</span>beta</span>
<span id="cb12-59"><a href="#cb12-59"></a></span>
<span id="cb12-60"><a href="#cb12-60"></a><span class="co"># get initial activity center starting values</span></span>
<span id="cb12-61"><a href="#cb12-61"></a>s.st =<span class="st"> </span>rescale_list<span class="op">$</span>s.st</span>
<span id="cb12-62"><a href="#cb12-62"></a></span>
<span id="cb12-63"><a href="#cb12-63"></a><span class="co"># define all initial values</span></span>
<span id="cb12-64"><a href="#cb12-64"></a>inits =<span class="st"> </span><span class="kw">list</span>(<span class="dt">sigma =</span> <span class="kw">runif</span>(<span class="dv">1</span>, <span class="dv">250</span>, <span class="dv">350</span>),<span class="dt">su =</span> s.st,<span class="dt">psiu=</span><span class="kw">runif</span>(<span class="dv">1</span>,<span class="fl">0.4</span>,<span class="fl">0.6</span>),</span>
<span id="cb12-65"><a href="#cb12-65"></a><span class="dt">lam0 =</span> <span class="kw">runif</span>(<span class="dv">1</span>, <span class="fl">0.1</span>, <span class="fl">0.3</span>),<span class="dt">pOKu=</span>data<span class="op">$</span>OKu,<span class="dt">zu=</span><span class="kw">rbinom</span>(constants<span class="op">$</span>m,<span class="dv">1</span>,<span class="fl">0.5</span>))</span>
<span id="cb12-66"><a href="#cb12-66"></a></span>
<span id="cb12-67"><a href="#cb12-67"></a><span class="co"># parameters to monitor</span></span>
<span id="cb12-68"><a href="#cb12-68"></a>params =<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;sigma&quot;</span>,<span class="st">&quot;psiu&quot;</span>,<span class="st">&quot;lam0&quot;</span>,<span class="st">&quot;N&quot;</span>,<span class="st">&quot;D&quot;</span>,<span class="st">&quot;su&quot;</span>,<span class="st">&quot;zu&quot;</span>)</span>
<span id="cb12-69"><a href="#cb12-69"></a></span>
<span id="cb12-70"><a href="#cb12-70"></a><span class="co"># get model</span></span>
<span id="cb12-71"><a href="#cb12-71"></a>sc_model =<span class="st"> </span><span class="kw">get_unmarked</span>(<span class="dt">occ_specific =</span> <span class="ot">FALSE</span>, <span class="dt">hab_mask =</span> <span class="ot">TRUE</span>, </span>
<span id="cb12-72"><a href="#cb12-72"></a>                        <span class="dt">trapsClustered =</span> <span class="ot">TRUE</span>)</span>
<span id="cb12-73"><a href="#cb12-73"></a></span>
<span id="cb12-74"><a href="#cb12-74"></a><span class="co"># model code to replace old code</span></span>
<span id="cb12-75"><a href="#cb12-75"></a>add_model =<span class="st"> </span><span class="kw">nimbleCode</span>({</span>
<span id="cb12-76"><a href="#cb12-76"></a>  lam0[g] <span class="op">~</span><span class="st"> </span><span class="kw">dgamma</span>(alpha_lam0,<span class="dv">1</span><span class="op">/</span>beta_lam0)</span>
<span id="cb12-77"><a href="#cb12-77"></a>  sigma <span class="op">~</span><span class="st"> </span><span class="kw">dgamma</span>(alpha, <span class="dv">1</span><span class="op">/</span>beta)</span>
<span id="cb12-78"><a href="#cb12-78"></a>})</span>
<span id="cb12-79"><a href="#cb12-79"></a></span>
<span id="cb12-80"><a href="#cb12-80"></a><span class="co"># now create new model</span></span>
<span id="cb12-81"><a href="#cb12-81"></a>sc_model_inf =<span class="st"> </span><span class="kw">customize_model</span>(sc_model, add_model, <span class="dt">append_line =</span> <span class="kw">c</span>(<span class="dv">3</span>,<span class="dv">4</span>),</span>
<span id="cb12-82"><a href="#cb12-82"></a>                               <span class="dt">remove_line =</span> <span class="kw">c</span>(<span class="dv">3</span>,<span class="dv">5</span>))</span>
<span id="cb12-83"><a href="#cb12-83"></a></span>
<span id="cb12-84"><a href="#cb12-84"></a><span class="co"># inspect model (not run)</span></span>
<span id="cb12-85"><a href="#cb12-85"></a><span class="co"># sc_model_inf</span></span>
<span id="cb12-86"><a href="#cb12-86"></a></span>
<span id="cb12-87"><a href="#cb12-87"></a><span class="co"># run model (need to set s_alias)</span></span>
<span id="cb12-88"><a href="#cb12-88"></a><span class="kw">library</span>(tictoc)</span>
<span id="cb12-89"><a href="#cb12-89"></a><span class="kw">tic</span>() <span class="co"># track time elapsed</span></span>
<span id="cb12-90"><a href="#cb12-90"></a>out =<span class="st"> </span><span class="kw">run_classic</span>(<span class="dt">model =</span> sc_model_inf, <span class="dt">data=</span>data, <span class="dt">constants=</span>constants,</span>
<span id="cb12-91"><a href="#cb12-91"></a><span class="dt">inits=</span>inits, <span class="dt">params =</span> params,<span class="dt">niter =</span> <span class="dv">10000</span>, <span class="dt">nburnin=</span><span class="dv">1000</span>, <span class="dt">thin=</span><span class="dv">1</span>, <span class="dt">nchains=</span><span class="dv">2</span>, </span>
<span id="cb12-92"><a href="#cb12-92"></a><span class="dt">parallel=</span><span class="ot">TRUE</span>, <span class="dt">RNGseed =</span> <span class="dv">500</span>, <span class="dt">s_alias =</span> <span class="st">&quot;su&quot;</span>)</span>
<span id="cb12-93"><a href="#cb12-93"></a><span class="kw">toc</span>()</span>
<span id="cb12-94"><a href="#cb12-94"></a><span class="co">#&gt; 968.93 sec elapsed</span></span>
<span id="cb12-95"><a href="#cb12-95"></a></span>
<span id="cb12-96"><a href="#cb12-96"></a><span class="co"># summary table of MCMC output (exclude &quot;su&quot; and &quot;zu&quot; parameters)</span></span>
<span id="cb12-97"><a href="#cb12-97"></a><span class="kw">nimSummary</span>(out, <span class="dt">exclude =</span> <span class="kw">c</span>(<span class="st">&quot;su&quot;</span>,<span class="st">&quot;zu&quot;</span>))</span>
<span id="cb12-98"><a href="#cb12-98"></a><span class="co">#&gt;         post.mean post.sd    q2.5     q50   q97.5 f0    n.eff  Rhat</span></span>
<span id="cb12-99"><a href="#cb12-99"></a><span class="co">#&gt; D           0.102   0.022   0.066   0.099   0.152  1  270.831 1.008</span></span>
<span id="cb12-100"><a href="#cb12-100"></a><span class="co">#&gt; N         228.569  49.067 149.000 223.000 342.000  1  270.831 1.008</span></span>
<span id="cb12-101"><a href="#cb12-101"></a><span class="co">#&gt; lam0[1]     0.295   0.027   0.247   0.294   0.352  1 3595.823 1.002</span></span>
<span id="cb12-102"><a href="#cb12-102"></a><span class="co">#&gt; lam0[2]     0.299   0.027   0.249   0.298   0.355  1 2805.852 1.001</span></span>
<span id="cb12-103"><a href="#cb12-103"></a><span class="co">#&gt; psiu         0.581   0.125   0.376   0.569   0.865  1  305.124 1.007</span></span>
<span id="cb12-104"><a href="#cb12-104"></a><span class="co">#&gt; sigma     295.497  27.822 243.024 295.005 352.028  1  319.216 1.002</span></span></code></pre></div>
<br>
<p>
These results are similar to our model run in part 4 with the informative priors as expected. We again make a realized density surface and note that the <code>realized_density()</code> function outputs a list of length 2 in this example since we have 2 spatially separated trapping grids here that are in a 3-dimensional array format. We’ll need to provide the extent <code>ext = GridX$ext</code> since we have a 3-dimensional trapping array.
</p>
<p><br></p>
<div class="sourceCode" id="cb13"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1"></a><span class="co"># generate realized density surface (note setting z_alias and s_alias)</span></span>
<span id="cb13-2"><a href="#cb13-2"></a>r =<span class="st"> </span><span class="kw">realized_density</span>(<span class="dt">samples=</span>out, <span class="dt">grid=</span>GridX<span class="op">$</span>grid, <span class="dt">ext =</span> GridX<span class="op">$</span>ext,</span>
<span id="cb13-3"><a href="#cb13-3"></a>                      <span class="dt">crs_=</span>mycrs,<span class="dt">site=</span>constants<span class="op">$</span>site, <span class="dt">hab_mask=</span>hab_mask,</span>
<span id="cb13-4"><a href="#cb13-4"></a>                       <span class="dt">z_alias =</span> <span class="st">&quot;zu&quot;</span>, <span class="dt">s_alias =</span> <span class="st">&quot;su&quot;</span>)</span>
<span id="cb13-5"><a href="#cb13-5"></a></span>
<span id="cb13-6"><a href="#cb13-6"></a><span class="co"># load needed packages for multiplot</span></span>
<span id="cb13-7"><a href="#cb13-7"></a><span class="kw">library</span>(viridis) </span>
<span id="cb13-8"><a href="#cb13-8"></a><span class="kw">library</span>(grid)</span>
<span id="cb13-9"><a href="#cb13-9"></a><span class="kw">library</span>(cowplot)</span>
<span id="cb13-10"><a href="#cb13-10"></a><span class="kw">library</span>(ggpubr) </span>
<span id="cb13-11"><a href="#cb13-11"></a><span class="kw">library</span>(rasterVis)</span>
<span id="cb13-12"><a href="#cb13-12"></a></span>
<span id="cb13-13"><a href="#cb13-13"></a><span class="co"># plot raster from site 1</span></span>
<span id="cb13-14"><a href="#cb13-14"></a>p1&lt;-<span class="kw">gplot</span>(r[[<span class="dv">1</span>]]) <span class="op">+</span><span class="st"> </span><span class="kw">geom_raster</span>(<span class="kw">aes</span>(<span class="dt">fill =</span> value)) <span class="op">+</span></span>
<span id="cb13-15"><a href="#cb13-15"></a><span class="st">          </span><span class="kw">scale_fill_viridis</span>(<span class="dt">na.value =</span> <span class="ot">NA</span>, <span class="dt">name=</span><span class="st">&quot;Density&quot;</span>,</span>
<span id="cb13-16"><a href="#cb13-16"></a>          <span class="dt">limits=</span><span class="kw">c</span>(<span class="dv">0</span>,<span class="fl">0.3</span>),<span class="dt">breaks=</span><span class="kw">seq</span>(<span class="dv">0</span>,<span class="fl">0.3</span>,<span class="dt">by=</span><span class="fl">0.1</span>)) <span class="op">+</span></span>
<span id="cb13-17"><a href="#cb13-17"></a><span class="st">          </span><span class="kw">xlab</span>(<span class="st">&quot;&quot;</span>) <span class="op">+</span><span class="st"> </span><span class="kw">ylab</span>(<span class="st">&quot;&quot;</span>) <span class="op">+</span><span class="st"> </span><span class="kw">theme_classic</span>() <span class="op">+</span></span>
<span id="cb13-18"><a href="#cb13-18"></a><span class="st">          </span><span class="kw">scale_x_continuous</span>(<span class="dt">expand=</span><span class="kw">c</span>(<span class="dv">0</span>, <span class="dv">0</span>)) <span class="op">+</span><span class="st"> </span></span>
<span id="cb13-19"><a href="#cb13-19"></a><span class="st">          </span><span class="kw">scale_y_continuous</span>(<span class="dt">expand=</span><span class="kw">c</span>(<span class="dv">0</span>, <span class="dv">0</span>)) <span class="op">+</span><span class="st"> </span></span>
<span id="cb13-20"><a href="#cb13-20"></a><span class="st">           </span><span class="kw">theme</span>(<span class="dt">axis.text =</span> <span class="kw">element_text</span>(<span class="dt">size=</span><span class="dv">18</span>))</span>
<span id="cb13-21"><a href="#cb13-21"></a></span>
<span id="cb13-22"><a href="#cb13-22"></a><span class="co"># plot raster from site 2</span></span>
<span id="cb13-23"><a href="#cb13-23"></a>p2&lt;-<span class="kw">gplot</span>(r[[<span class="dv">2</span>]]) <span class="op">+</span><span class="st"> </span><span class="kw">geom_raster</span>(<span class="kw">aes</span>(<span class="dt">fill =</span> value)) <span class="op">+</span></span>
<span id="cb13-24"><a href="#cb13-24"></a><span class="st">          </span><span class="kw">scale_fill_viridis</span>(<span class="dt">na.value =</span> <span class="ot">NA</span>, <span class="dt">name=</span><span class="st">&quot;Density&quot;</span>,</span>
<span id="cb13-25"><a href="#cb13-25"></a>          <span class="dt">limits=</span><span class="kw">c</span>(<span class="dv">0</span>,<span class="fl">0.3</span>),<span class="dt">breaks=</span><span class="kw">seq</span>(<span class="dv">0</span>,<span class="fl">0.3</span>,<span class="dt">by=</span><span class="fl">0.1</span>)) <span class="op">+</span></span>
<span id="cb13-26"><a href="#cb13-26"></a><span class="st">          </span><span class="kw">xlab</span>(<span class="st">&quot;&quot;</span>) <span class="op">+</span><span class="st"> </span><span class="kw">ylab</span>(<span class="st">&quot;&quot;</span>) <span class="op">+</span><span class="st"> </span><span class="kw">theme_classic</span>() <span class="op">+</span><span class="st"> </span></span>
<span id="cb13-27"><a href="#cb13-27"></a><span class="st">          </span><span class="kw">scale_x_continuous</span>(<span class="dt">expand=</span><span class="kw">c</span>(<span class="dv">0</span>, <span class="dv">0</span>)) <span class="op">+</span><span class="st"> </span></span>
<span id="cb13-28"><a href="#cb13-28"></a><span class="st">          </span><span class="kw">scale_y_continuous</span>(<span class="dt">expand=</span><span class="kw">c</span>(<span class="dv">0</span>, <span class="dv">0</span>)) <span class="op">+</span><span class="st"> </span></span>
<span id="cb13-29"><a href="#cb13-29"></a><span class="st">          </span><span class="kw">theme</span>(<span class="dt">axis.text =</span> <span class="kw">element_text</span>(<span class="dt">size=</span><span class="dv">18</span>))</span>
<span id="cb13-30"><a href="#cb13-30"></a></span>
<span id="cb13-31"><a href="#cb13-31"></a><span class="co"># arrange the two plots in a single row</span></span>
<span id="cb13-32"><a href="#cb13-32"></a>prow &lt;-<span class="st"> </span><span class="kw">plot_grid</span>(p1 <span class="op">+</span><span class="st"> </span><span class="kw">theme</span>(<span class="dt">legend.position=</span><span class="st">&quot;none&quot;</span>),</span>
<span id="cb13-33"><a href="#cb13-33"></a>           p2 <span class="op">+</span><span class="st"> </span><span class="kw">theme</span>(<span class="dt">legend.position=</span><span class="st">&quot;none&quot;</span>),</span>
<span id="cb13-34"><a href="#cb13-34"></a>           <span class="dt">align =</span> <span class="st">&#39;vh&#39;</span>,</span>
<span id="cb13-35"><a href="#cb13-35"></a>           <span class="dt">labels =</span> <span class="ot">NULL</span>,</span>
<span id="cb13-36"><a href="#cb13-36"></a>           <span class="dt">hjust =</span> <span class="dv">-1</span>,</span>
<span id="cb13-37"><a href="#cb13-37"></a>           <span class="dt">nrow =</span> <span class="dv">1</span></span>
<span id="cb13-38"><a href="#cb13-38"></a>           )</span>
<span id="cb13-39"><a href="#cb13-39"></a></span>
<span id="cb13-40"><a href="#cb13-40"></a><span class="co"># extract the legend from one of the plots</span></span>
<span id="cb13-41"><a href="#cb13-41"></a>legend_t &lt;-<span class="st"> </span><span class="kw">get_legend</span>(p1 <span class="op">+</span><span class="st"> </span><span class="kw">theme</span>(<span class="dt">legend.position =</span> <span class="st">&quot;top&quot;</span>,</span>
<span id="cb13-42"><a href="#cb13-42"></a>                        <span class="dt">legend.direction =</span> <span class="st">&quot;horizontal&quot;</span>,</span>
<span id="cb13-43"><a href="#cb13-43"></a>                        <span class="dt">legend.text =</span> <span class="kw">element_text</span>(<span class="dt">size=</span><span class="dv">14</span>),</span>
<span id="cb13-44"><a href="#cb13-44"></a>                        <span class="dt">legend.title =</span> <span class="kw">element_text</span>(<span class="dt">size=</span><span class="dv">16</span>)))</span>
<span id="cb13-45"><a href="#cb13-45"></a></span>
<span id="cb13-46"><a href="#cb13-46"></a><span class="co"># add the legend above the row we made earlier. Give it 20% of the height</span></span>
<span id="cb13-47"><a href="#cb13-47"></a><span class="co"># of one plot (via rel_heights).</span></span>
<span id="cb13-48"><a href="#cb13-48"></a>pcomb &lt;-<span class="st"> </span><span class="kw">plot_grid</span>(legend_t, prow, <span class="dt">ncol =</span> <span class="dv">1</span>, <span class="dt">rel_heights =</span> <span class="kw">c</span>(.<span class="dv">2</span>, <span class="dv">1</span>))</span>
<span id="cb13-49"><a href="#cb13-49"></a></span>
<span id="cb13-50"><a href="#cb13-50"></a><span class="co"># add x and y axis labels</span></span>
<span id="cb13-51"><a href="#cb13-51"></a>pcomb &lt;-<span class="kw">annotate_figure</span>(pcomb, <span class="dt">bottom =</span> <span class="kw">textGrob</span>(<span class="st">&quot;Easting&quot;</span>, </span>
<span id="cb13-52"><a href="#cb13-52"></a>              <span class="dt">gp=</span><span class="kw">gpar</span>(<span class="dt">fontsize=</span><span class="dv">18</span>), <span class="dt">vjust =</span> <span class="dv">-1</span>, <span class="dt">hjust =</span> <span class="dv">0</span>),</span>
<span id="cb13-53"><a href="#cb13-53"></a>              <span class="dt">left =</span> <span class="kw">textGrob</span>(<span class="st">&quot;Northing&quot;</span>, <span class="dt">rot=</span><span class="dv">90</span>, <span class="dt">gp=</span><span class="kw">gpar</span>(<span class="dt">fontsize=</span><span class="dv">18</span>),</span>
<span id="cb13-54"><a href="#cb13-54"></a>              <span class="dt">vjust =</span> <span class="dv">1</span>, <span class="dt">hjust =</span> <span class="fl">0.5</span>))</span>
<span id="cb13-55"><a href="#cb13-55"></a>pcomb</span></code></pre></div>
<br>
<p align="center">
<img src="../man/figures/vignette_02/Fig9.png" style="width:90%"/>
</p>
<br>
<p>
Way to go! You’ve made it through the second ‘localSCR’ tutorial. Please see Royle et al. (2014) for more details about spatial count theory and modeling. The next tutorial will be similar but focused on spatial mark-resight models that make inference to abundance/density for marked/unmarked populations.
</p>
<p><br></p>
</div>
</div>
<div id="references" class="section level2">
<h2>References</h2>
<p>Chandler, R. B. 2018. Speeding up data augmentation in BUGS. <a href="https://groups.google.com/forum/#!topic/hmecology/o6cWDqHHgOE" class="uri">https://groups.google.com/forum/#!topic/hmecology/o6cWDqHHgOE</a>.</p>
<p>de Valpine P, C. Paciorek, D. Turek, N. Michaud, C. Anderson-Bergman, F. Obermeyer, C. C. Wehrhahn, A. Rodrìguez, L. D. Temple, and S. Paganin. 2022. <em>NIMBLE: MCMC, Particle Filtering, and Programmable Hierarchical Modeling</em>. doi: 10.5281/zenodo.1211190 (URL: <a href="https://doi.org/10.5281/zenodo.1211190" class="uri">https://doi.org/10.5281/zenodo.1211190</a>), R package version 0.12.2, URL:<a href="https://cran.r-project.org/package=nimble" class="uri">https://cran.r-project.org/package=nimble</a>.</p>
<p>Furnas, B. J., R. H. Landers, S. Hill, S. S. Itoga, and B. N. Sacks. 2018. Integrated modeling to estimate population size and composition of mule deer. Journal of Wildlife Management 82:1429–1441.</p>
<p>Milleret, C., P. Dupont, C. Bonenfant, H. Henrik Brøseth, Ø. Flagstad, C. Sutherland, and R. Bischof. 2019. A local evaluation of the individual state‐space to scale up Bayesian spatial capture‐recapture. Ecology a Evolution 9:352–363.</p>
<p>Turek, D., C. Milleret, T. Ergon, and H. Brøseth 2021. Efficient estimation of large‐scale spatial capture–recapture model. Ecosphere <a href="DOI:10.1002/ecs2.338" class="uri">DOI:10.1002/ecs2.338</a>5.</p>
<p>Royle, J. A., R. B. Chandler, R. Sollmann, and B. Gardner. 2014. Spatial capture‐recapture. Academic Press, Waltham, Massachusetts, USA.</p>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="pkgdown-sidebar">

        <nav id="toc" data-toggle="toc"><h2 data-toc-skip>Contents</h2>
    </nav>
      </div>

</div>



      <footer><div class="copyright">
  <p></p><p>Developed by Daniel Eacker.</p>
</div>

<div class="pkgdown">
  <p></p><p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.0.2.</p>
</div>

      </footer></div>

  


  

  </body></html>
