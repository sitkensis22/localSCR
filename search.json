[{"path":"https://sitkensis22.github.io/localSCR/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2022 Daniel Eacker Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://sitkensis22.github.io/localSCR/articles/classic_scr.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Classic SCR models: continuous state-space and marked individuals","text":"first vignette ‘localSCR’ package covers define set ‘classic’ Bayesian spatial capture-recapture (SCR) models (Royle et al. 2014). models designed model SCR data ‘marked’ individuals assumption uniformly distributed activity centers (.e,. continuous state-space). Although many distance detection functions possible, package currently models encounter process assumption bivariate normal model space use, commonly employed literature. package meant ease implementation Bayesian SCR models using ‘nimble’ package (de Valpine et . 2022), allows increased flexibilty ability user include custom functions assign different algorithms specific model parameters. took advantage functionality goal building simple, straightforward workflow flexible enough handle mainstream SCR analysis problems. Visit https://r-nimble.org/download information installing ‘nimble’ Rtools computer.  ‘localSCR’ package implements Bayesian SCR models using ‘nimble’ package (de Valpine et . 2022) following methods described Royle et al. (2014). take advantage recent developments computation SCR models. tutorial, three methods implemented decrease computational run time: Block updating x y activity center coordinates (Turek et al. 2021) Using vectorized declarations traps distance function calculations Separating data augmentation process two steps (Chandler 2018) SCR problems, landscape features create ‘unsuitable’ habitat study species. Habitat masks used account features designate suitable (1) unsuitable (0) habitat, can represented matrix array binary values. follow methods Milletet et al. (2019) implement “ones” trick account habitat suitability. restricts possible locations latent activity centers suitable habitat. ‘localSCR’ package provides functions construct habitat mask either raster polygon data.","code":""},{"path":"https://sitkensis22.github.io/localSCR/articles/classic_scr.html","id":"turtorial","dir":"Articles","previous_headings":"","what":"Turtorial","title":"Classic SCR models: continuous state-space and marked individuals","text":"tutorial includes four parts: Create traps (detectors) construct state-space Simulate ‘classic’ SCR data using state-space extent Workflow 2-D trap array including sex-specific scaling parameter habitat mask Workflow 3-D trap array including sex-specific scaling parameter habitat mask","code":""},{"path":"https://sitkensis22.github.io/localSCR/articles/classic_scr.html","id":"functions-used-from-localscr-package","dir":"Articles","previous_headings":"","what":"Functions used from ‘localSCR’ package:","title":"Classic SCR models: continuous state-space and marked individuals","text":"grid_classic() define state-space grid extent sim_classic() simulate basic spatial capture-recapture data mask_polygon() create habitat mask matrix array polygon initialize_classic() generate starting locations activity area centers rescale_classic() rescale inputs prepare data using habitat mask get_classic() grabs template model given inputs using nimbleCode() function run_classic() wrapper function run classic models using ‘nimble’ package nimSummary() summarize lists Markov Chain Monte Carlo (MCMC) output realized_density() generate realized density surface MCMC output Note: see references bottom page ### (1) Simulate single trap array random positional noise create state-space   , can see state-space grid created grid_classic(). Also, traps (detectors) plotted top blue. arbitrarily chose grid resolution 100 example (.g., res = 100), vary problem. situations, prudent test effect different grid resolutions estimated abundance density SCR models (see Royle et al. 2014). Also, note use EPSG code define coordinate reference system state-space (see https://epsg.io/32608). ### (2) Simulate SCR data make plot .   plot can see point sizes relative number detections (‘Ndet’) simulated individual. Although individuals detected near grid large number detections, still pick individuals multiple times edge grid just chance. Also, point pattern appears random drawing simulated activity center coordinates using runif(), adheres assumption random distribution individual activity centers across state-space classis SCR analysis. Next, ’ll create trap array ’ll set sex-specific scaling parameter (sigma_) 220 m 300 m, represent smaller female larger male activity area sizes. order fully-specify sex-specific scaling parameter sim_classic(), need set 0 > prop_sex < 1, otherwise simulation use single scaling parameter. example, also specify enc_dist = \"binomial use binomial encounter probability model; available option Poisson distribution (enc_dist = \"poisson). add additional layer complexity introducing habitat mask. constructing polygon feature using ‘sf’ package, use function mask_polygon() build habitat mask matrix object. habitat matrix either ‘0’ (unsuitable) ‘1’ (suitable). habitat matrix rows represent y-coordinate (“Northing”) state-space grid columns represent x-coordinate (“Easting”) state-space grid. ’ll use habitat matrix data part tutorial. ### (3) Workflow simple SCR model sex-specific sigma, binomial encounter distribution, habitat mask   figure can see effect polygon creating habitat mask state-space. initialize_classic() function contains initial activity center locations within polygon (note points edges suitable habitat continuous location discretized checked habitat mask).    can see histogram posterior samples N model estimates close simulated value 200 individuals (shows red line) biased slightly low around 186 individuals. expected since one realization detection process. example, divided pixelWidth 100 deriving area () list constants. allowed us estimate density activity centers/100 m2 rather activity centers/m2. Note care must taken rescaling data constants.   Next repeat similar workflow now two trap arrays clustered space, thus, negligble chance detecting individual one trap array. case, functions ‘localSCR’ can automatically detect traps 3-dimensional format note sim_classic return variable called site identifies trap array individual (detected augmented) belongs . Note number rows simulated data y equal simulated population size (example, N = 200). However, using trick provided Chandler (2018) separate data augmentation process two steps, need encounter data individuals detected model likelihood. Also, occasion-specific detection covariates, can sum y individuals traps result 2-dimensional encounter history array (.e., y[,j]). speeds us model conditions can specify get SCR model using get_classic(y_dim = 2,...) setting y_dim = 2. Otherwise, workflow similar 2-dimensional trap array previous example. ### (4) Workflow simple SCR model sex-specific sigma, binomial encounter distribution, habitat mask using 3D trap array clustered traps.  figure can see two spatially separated trapping grids polgon overlaps grided area. area outside polygon considere unsuitable habitat matrix created. Note site variable long simulated population size (, 200) thus, need augment variable length equal total augmented population size (.e., M = 400). Otherwise workflow similar previous one.    trace plots show bit autocorrelation might run iterations everything nicely converged. However, note 2 minutes needed MCMC sampling finish even Windows 64-bit machine 8 GB RAM.   ’s ! ’ve made first ‘localSCR’ tutorial. Please see Royle et al. (2014) details SCR theory modeling. next tutorial similar focused spatial count models make inference abundance/density unmarked populations. ## References Chandler, R. B. 2018. Speeding data augmentation BUGS. https://groups.google.com/forum/#!topic/hmecology/o6cWDqHHgOE. de Valpine P, C. Paciorek, D. Turek, N. Michaud, C. Anderson-Bergman, F. Obermeyer, C. C. Wehrhahn, . Rodrìguez, L. D. Temple, S. Paganin. 2022. NIMBLE: MCMC, Particle Filtering, Programmable Hierarchical Modeling. doi: 10.5281/zenodo.1211190 (URL: https://doi.org/10.5281/zenodo.1211190), R package version 0.12.2, URL:https://cran.r-project.org/package=nimble. Furnas, B. J., R. H. Landers, S. Hill, S. S. Itoga, B. N. Sacks. 2018. Integrated modeling estimate population size composition mule deer. Journal Wildlife Management 82:1429–1441. Turek, D., C. Milleret, T. Ergon, H. Brøseth 2021. Efficient estimation large‐scale spatial capture–recapture model. Ecosphere DOI:10.1002/ecs2.3385. Royle, J. ., R. B. Chandler, R. Sollmann, B. Gardner. 2014. Spatial capture‐recapture. Academic Press, Waltham, Massachusetts, USA.","code":"# load 'localSCR' package library(localSCR) # simulate a single trap array with random positional noise x <- seq(-800, 800, length.out = 5) y <- seq(-800, 800, length.out = 5) traps <- as.matrix(expand.grid(x = x, y = y)) traps <- traps + runif(prod(dim(traps)),-20,20) # add some random noise to locations  mysigma = 300 # simulate sigma of 300 m mycrs = 32608 # EPSG for WGS 84 / UTM zone 8N  # create state-space Grid = grid_classic(X = traps, crs_ = mycrs, buff = 3*mysigma, res = 100)  # make ggplot of grid and trap locations library(ggplot2) ggplot() + geom_point(data=as.data.frame(Grid$grid),aes(x=x,y=y),color=\"grey60\",size=1.25) +      geom_point(data=as.data.frame(traps),aes(x=x,y=y),color=\"blue\",size=2) +     theme_classic() + ylab(\"Northing\") + xlab(\"Easting\") +     scale_x_continuous(expand=c(-0.1, 0.1)) +      scale_y_continuous(expand=c(-0.1, 0.1)) +      theme(axis.text = element_text(size=12),axis.title = element_text(size=16)) # simulate SCR data data3d = sim_classic(X = traps, ext = Grid$ext, crs_ = mycrs, sigma_ = mysigma, prop_sex = 1, N = 200, K = 4, base_encounter = 0.10, enc_dist = \"binomial\",  hab_mask = FALSE, setSeed = 100)  # inspect simulated data str(data3d) #> List of 3 #>  $ y  : int [1:200, 1:25, 1:4] 0 0 0 0 0 0 0 0 0 0 ... #>  $ sex: int [1:200] 1 1 1 1 1 1 1 1 1 1 ... #>  $ s  : num [1:200, 1:2] -659 -831 182 -1522 -106 ... #>   ..- attr(*, \"dimnames\")=List of 2 #>   .. ..$ : NULL #>   .. ..$ : chr [1:2] \"sx\" \"sy\"  # bind simulated activity centers with vector of the number of individual detections sdata = as.data.frame(cbind(data3d$s,Ndet=apply(data3d$y,1,sum)))   # make ggplot ggplot() + geom_point(data=as.data.frame(Grid$grid),aes(x=x,y=y),color=\"grey60\",size=1.25) +      geom_point(data=as.data.frame(traps),aes(x=x,y=y),color=\"blue\",size=2) +     geom_point(data=sdata,aes(x=sx,y=sy,size=Ndet),color=\"orangered\",alpha=0.75) +     theme_classic() + ylab(\"Northing\") + xlab(\"Easting\") +     scale_x_continuous(expand=c(0.025, 0.025)) +  scale_size_continuous(range = c(2, 7)) +      scale_y_continuous(expand=c(0.025, 0.025)) +      theme(axis.text = element_text(size=12),axis.title = element_text(size=16)) # simulate a single trap array with random positional noise x <- seq(-800, 800, length.out = 5) y <- seq(-800, 800, length.out = 5) traps <- as.matrix(expand.grid(x = x, y = y)) traps <- traps + runif(prod(dim(traps)),-20,20) # add some random noise to locations  mysigma = c(220, 300) # simulate sex-specific mycrs = 32608 # EPSG for WGS 84 / UTM zone 8N pixelWidth = 100 # store pixelWidth or grid resolution  # create state-space grid and extent Grid = grid_classic(X = traps, crs_ = mycrs, buff = 3*max(mysigma), res = pixelWidth)   # create polygon for mask library(sf) #> Linking to GEOS 3.8.0, GDAL 3.0.4, PROJ 6.3.1; sf_use_s2() is TRUE poly = st_sfc(st_polygon(x=list(matrix(c(-1765,-1765,1730,-1650,1600,1650,0,1350,-800,1700, -1850,1000,-1765,-1765),ncol=2, byrow=TRUE))), crs =  mycrs)  # create habitat mask hab_mask = mask_polygon(poly = poly, grid = Grid$grid, crs_ = mycrs,  prev_mask = NULL)  # simulate data for uniform state-space and habitat mask data3d = sim_classic(X = traps, ext = Grid$ext, crs_ = mycrs, sigma_ = mysigma, prop_sex = 0.7, N = 200, K = 4, base_encounter = 0.15, enc_dist = \"binomial\", hab_mask = hab_mask, setSeed = 100)  # total augmented population size  M = 400  # get initial activity center starting values s.st3d = initialize_classic(y=data3d$y, M=M, X=traps, buff = 3*max(mysigma), hab_mask = hab_mask)  # bind simulated activity centers with vector of either 1 (detected) or 0 (not detected) s.stdata = as.data.frame(cbind(s.st3d,Det=c(as.numeric(apply(data3d$y,1,sum)>0), rep(0,M-nrow(data3d$y)))))  # convert Det to factor s.stdata$Det = as.factor(s.stdata$Det)    # make ggplot ggplot() + geom_point(data=as.data.frame(Grid$grid),aes(x=x,y=y),color=\"grey60\",size=1.25) +      geom_point(data=as.data.frame(traps),aes(x=x,y=y),color=\"blue\",size=3) +     geom_point(data=s.stdata,aes(x=V1,y=V2,fill=Det,color=Det),size = 2.5) +     geom_sf(data=poly, fill = NA) + coord_sf(datum=st_crs(mycrs)) +     theme_classic() + ylab(\"Northing\") + xlab(\"Easting\") +     scale_x_continuous(expand=c(0.025, 0.025)) +      scale_color_manual(values = c(\"orangered\",\"springgreen\")) +     scale_y_continuous(expand=c(0.025, 0.025)) +      theme(axis.text = element_text(size=12),axis.title = element_text(size=16)) # rescale inputs rescale_list = rescale_classic(X = traps, ext = Grid$ext, s.st = s.st3d,  hab_mask = hab_mask)  # store rescaled extent ext = rescale_list$ext  # prepare data data = list(y=data3d$y) data$y = data$y[which(apply(data$y, 1, sum)!=0),,] # remove augmented records  data$y = apply(data$y, c(1,2), sum) # covert to 2d by summing over occasions  # add rescaled traps data$X = rescale_list$X  # prepare constants (note get density in activity center/100 m2 rather than activity centers/m2) constants = list(M = M,n0 = nrow(data$y),J=dim(data$y)[2], K=dim(data3d$y)[3], x_lower = ext[1], x_upper = ext[2], y_lower = ext[3], y_upper = ext[4], sigma_upper = 1000, A = (sum(hab_mask)*(pixelWidth/100)^2),pixelWidth=pixelWidth)  # augment sex data$sex = c(data3d$sex,rep(NA,constants$M-length(data3d$sex)))  # add z and zeros vector data for latent inclusion indicator data$z = c(rep(1,constants$n0),rep(NA,constants$M - constants$n0)) data$zeros =  c(rep(NA,constants$n0),rep(0,constants$M - constants$n0))  # add hab_mask and OK for habitat check data$hab_mask = hab_mask data$OK = rep(1,constants$M)  # get initial activity center starting values s.st3d = rescale_list$s.st  # define all initial values inits = list(sigma = runif(2, 250, 350), s = s.st3d,psi=runif(1,0.2,0.3), p0 = runif(1, 0.05, 0.15),pOK=data$OK,z=c(rep(NA,constants$n0), rep(0,constants$M-constants$n0)))  # parameters to monitor params = c(\"sigma\",\"psi\",\"p0\",\"N\",\"D\",\"psi_sex\",\"s\",\"z\")  # get model scr_model = get_classic(dim_y = 2, enc_dist = \"binomial\",sex_sigma = TRUE,hab_mask=TRUE, trapsClustered=FALSE)  # run model library(tictoc) tic() # track time elapsed out = run_classic(model = scr_model, data=data, constants=constants, inits=inits, params = params,niter = 10000, nburnin=1000, thin=1, nchains=2, parallel=TRUE,  RNGseed = 500) toc() #> 104.414 sec elapsed  # summarize output samples = do.call(rbind, out) par(mfrow=c(1,1)) hist(samples[,which(dimnames(out[[1]])[[2]]==\"N\")], xlab = \"Abundance\", xlim = c(0,500), main=\"\") abline(v=200, col=\"red\") # add line for simulated abundance # summarize MCMC samples (exclude parameters and don't plot) nimSummary(out, exclude_params = c(\"s\",\"z\"), trace=FALSE) #>          post.mean post.sd    q2.5     q50   q97.5 f0   n.eff  Rhat #> D            0.217   0.027   0.174   0.214   0.279  1 287.723 1.003 #> N          232.708  28.761 186.000 229.000 298.000  1 287.723 1.003 #> p0           0.133   0.024   0.091   0.131   0.183  1 405.761 1.012 #> psi          0.581   0.076   0.456   0.574   0.749  1 298.192 1.003 #> psi_sex      0.758   0.054   0.648   0.761   0.855  1 465.875 1.003 #> sigma[1]   306.583  45.277 236.604 299.853 411.239  1 254.652 1.000 #> sigma[2]   278.029  25.147 232.727 276.585 331.032  1 273.259 1.011  # make realized density plot  r = realized_density(samples = out, grid = Grid$grid, crs_ = mycrs, site = NULL,  hab_mask = hab_mask)               # load virdiis color palette and raster libraries       library(viridis) #> Loading required package: viridisLite library(raster) #> Loading required package: sp  # make simple raster plot plot(r, col=viridis(100),main=expression(\"Realized density (activity centers/100 m\"^2*\")\"),      ylab=\"Northing\",xlab=\"Easting\") # simulate a single trap array with random positional noise x <- seq(-800, 800, length.out = 5) y <- seq(-800, 800, length.out = 5) traps <- as.matrix(expand.grid(x = x, y = y)) traps <- traps + runif(prod(dim(traps)),-20,20) # add some random noise to locations  mysigma = c(220, 300) # simulate sex-specific mycrs = 32608 # EPSG for WGS 84 / UTM zone 8N pixelWidth = 100 # store pixelWidth  # create an array of traps, as an approach where individuals will only be detected  # at one of the trap arrays (e.g., Furnas et al. 2018) Xarray = array(NA, dim=c(nrow(traps),2,2)) Xarray[,,1]=traps Xarray[,,2]=traps+4000 # shift trapping grid to new locations  # create grid and extent for 3D trap array GridX = grid_classic(X = Xarray, crs_ = mycrs, buff = 3*max(mysigma), res = 100)  # create polygon to use as a mask library(sf) poly = st_sfc(st_polygon(x=list(matrix(c(-1660,-1900,5730,-1050,5470, 5650,0,6050,-1800,5700,-1660,-1900),ncol=2, byrow=TRUE))), crs =  mycrs)  # make ggplot ggplot() + geom_point(data=as.data.frame(GridX$grid[,,1]),aes(x=V1,y=V2),color=\"grey60\",size=1.25) +     geom_point(data=as.data.frame(Xarray[,,1]),aes(x=V1,y=V2),color=\"blue\",size=2) +     geom_point(data=as.data.frame(GridX$grid[,,2]),aes(x=V1,y=V2),color=\"grey60\",size=1.25) +     geom_point(data=as.data.frame(Xarray[,,2]),aes(x=V1,y=V2),color=\"blue\",size=2) +     geom_sf(data=poly, fill = NA) + coord_sf(datum=st_crs(mycrs)) +     theme_classic() + ylab(\"Northing\") + xlab(\"Easting\") +     scale_x_continuous(limits=c(-2000,6000)) +     scale_y_continuous(limits=c(-2000,6000)) +      theme(axis.text = element_text(size=12),axis.title = element_text(size=16)) # get 3D habitat mask array for 3D grid hab_mask = mask_polygon(poly = poly, grid = GridX$grid, crs_ = mycrs,  prev_mask = NULL)  # simulate data for uniform state-space and habitat mask (N is simulated abundance per site) data4d = sim_classic(X = Xarray, ext = GridX$ext, crs_ = mycrs, sigma_ = mysigma, prop_sex = 0.7, N = 200, K = 4, base_encounter = 0.15, enc_dist = \"binomial\",hab_mask = hab_mask, setSeed = 500)  # total augmented population size  M = 400  # augment site identifier site = c(data4d$site,c(rep(1,((M-length(data4d$site))/2)),rep(2,((M-length(data4d$site))/2))))  # get initial activity center starting values  s.st4d = initialize_classic(y=data4d$y, M=M, X=Xarray, buff = 3*max(mysigma), site = site, hab_mask = hab_mask)  # rescale inputs rescale_list = rescale_classic(X = Xarray, ext = GridX$ext, s.st = s.st4d, site = site,  hab_mask = hab_mask)  # store rescaled extent and convert to matrix ext = do.call(rbind, lapply(rescale_list$ext, as.vector))  # prepare constants (note get density in activity center/100 m2 rather than activity centers/m2) constants = list(M = M,n0 =  length(which(apply(data4d$y,1,sum)!=0)), J=dim(data4d$y)[2], K=dim(data4d$y)[3], sigma_upper = 1000, A = (sum(hab_mask)*(pixelWidth/100)^2), pixelWidth=pixelWidth,nSites=dim(Xarray)[3],site = site)  # prepare data data = list(X = rescale_list$X,sex = c(data4d$sex,rep(NA,M-length(data4d$sex))), x_lower = ext[,1],x_upper = ext[,2],y_lower = ext[,3],y_upper = ext[,4])  # store and format encounter history data data$y = data4d$y[which(apply(data4d$y, 1, sum)!=0),,] # remove augmented records  data$y = apply(data$y, c(1,2), sum) # covert to 2d by summing over occasions  # add z and zeros vector data for latent inclusion indicator data$z = c(rep(1,constants$n0),rep(NA,constants$M - constants$n0)) data$zeros =  c(rep(NA,constants$n0),rep(0,constants$M - constants$n0))  # add hab_mask, proportion of available habitat, and OK for habitat check data$hab_mask = hab_mask data$prop.habitat=apply(hab_mask,3,mean) # need to adjust proportion of habitat available data$OK = rep(1,constants$M)  # get initial activity center starting values s.st = rescale_list$s.st  # define all initial values inits = list(sigma = runif(2, 250, 350), s = s.st,psi=runif(1,0.2,0.3), p0 = runif(dim(data$X)[3], 0.1, 0.2),sex=ifelse(is.na(data$sex), rbinom(constants$M-constants$n0,1,0.5),NA), pOK=data$OK,z=c(rep(NA,constants$n0),rep(0,constants$M-constants$n0)), psi_sex=runif(1,0.4,0.6))  # parameters to monitor params = c(\"sigma\",\"psi\",\"p0\",\"N\",\"D\",\"psi_sex\",\"s\",\"z\")  # get model scr_model = get_classic(dim_y = 2, enc_dist = \"binomial\",sex_sigma = TRUE,hab_mask=TRUE, trapsClustered = TRUE)  # run model library(tictoc) tic() # track time elapsed out = run_classic(model = scr_model, data=data, constants=constants, inits=inits, params = params,niter = 10000, nburnin=1000, thin=1, nchains=2,  parallel=TRUE, RNGseed = 500) toc() #> 104.613 sec elapsed  # summary table of MCMC output (exclude \"s\" and \"z\" parameters) nimSummary(out, exclude_params = c(\"s\",\"z\"), trace = TRUE, plot_all = FALSE) #>          post.mean post.sd    q2.5     q50   q97.5 f0   n.eff  Rhat #> D            0.100   0.015   0.074   0.098   0.136  1 221.187 1.063 #> N          223.906  34.525 166.000 221.000 306.000  1 221.187 1.063 #> p0[1]        0.112   0.027   0.066   0.109   0.173  1 531.737 1.005 #> p0[2]        0.108   0.024   0.069   0.106   0.162  1 534.815 1.006 #> psi          0.569   0.090   0.409   0.562   0.776  1 229.467 1.062 #> psi_sex      0.553   0.079   0.394   0.553   0.703  1 304.397 1.021 #> sigma[1]   252.076  37.377 192.030 247.679 335.659  1 264.634 1.009 #> sigma[2]   330.496  35.807 270.581 326.672 411.406  1 268.864 1.015 # generate realized density surface r = realized_density(samples=out, grid=GridX$grid, crs_=mycrs,                       site=constants$site, hab_mask=hab_mask)  # load needed packages for multiplot library(viridis)  library(grid) library(cowplot) library(ggpubr)  #>  #> Attaching package: 'ggpubr' #> The following object is masked from 'package:cowplot': #>  #>     get_legend #> The following object is masked from 'package:raster': #>  #>     rotate library(rasterVis) #> Loading required package: lattice  # plot raster from site 1 p1<-gplot(r[[1]]) + geom_raster(aes(fill = value)) +           scale_fill_viridis(na.value = NA, name=\"Density\",           limits=c(0,0.3),breaks=seq(0,0.3,by=0.1)) +           xlab(\"\") + ylab(\"\") + theme_classic() +           scale_x_continuous(expand=c(0, 0)) +            scale_y_continuous(expand=c(0, 0)) +             theme(axis.text = element_text(size=18))  # plot raster from site 2 p2<-gplot(r[[2]]) + geom_raster(aes(fill = value)) +           scale_fill_viridis(na.value = NA, name=\"Density\",           limits=c(0,0.3),breaks=seq(0,0.3,by=0.1)) +           xlab(\"\") + ylab(\"\") + theme_classic() +            scale_x_continuous(expand=c(0, 0)) +            scale_y_continuous(expand=c(0, 0)) +            theme(axis.text = element_text(size=18))  # arrange the two plots in a single row prow <- plot_grid(p1 + theme(legend.position=\"none\"),            p2 + theme(legend.position=\"none\"),            align = 'vh',            labels = NULL,            hjust = -1,            nrow = 1            ) #> Warning: Removed 12 rows containing missing values (geom_raster). #> Warning: Removed 54 rows containing missing values (geom_raster).  # extract the legend from one of the plots legend_t <- get_legend(p1 + theme(legend.position = \"top\",legend.direction = \"horizontal\", legend.text = element_text(size=14),legend.title = element_text(size=16))) #> Warning: Removed 12 rows containing missing values (geom_raster).  # add the legend above the row we made earlier. Give it 20% of the height # of one plot (via rel_heights). pcomb <- plot_grid(legend_t, prow, ncol = 1, rel_heights = c(.2, 1))  # add x and y axis labels pcomb <-annotate_figure(pcomb, bottom = textGrob(\"Easting\", gp=gpar(fontsize=18), vjust = -1, hjust = 0),left = textGrob(\"Northing\", rot=90,  gp=gpar(fontsize=18),vjust = 1, hjust = 0.5)) pcomb"},{"path":"https://sitkensis22.github.io/localSCR/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Daniel Eacker. Author, maintainer.","code":""},{"path":"https://sitkensis22.github.io/localSCR/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Eacker D (2022). localSCR: Supporting functions advanced Bayesian spatial capture-recapture modeling using 'nimble'. R package version 0.1.0, https://sitkensis22.github.io/localSCR/.","code":"@Manual{,   title = {localSCR: Supporting functions for advanced Bayesian spatial capture-recapture modeling using 'nimble'},   author = {Daniel Eacker},   year = {2022},   note = {R package version 0.1.0},   url = {https://sitkensis22.github.io/localSCR/}, }"},{"path":"https://sitkensis22.github.io/localSCR/index.html","id":"localscr","dir":"","previous_headings":"","what":"Supporting functions for advanced Bayesian spatial capture-recapture modeling using nimble","title":"Supporting functions for advanced Bayesian spatial capture-recapture modeling using nimble","text":"goal ‘localSCR’ provide user-friendly functions implement Bayesian spatial capture-recapture models (Royle et al. 2014) using ‘nimble’ package (de Valpine et . 2022) R. package currently functions 1) assist defining state-space grid extent given 2-dimensional 3-dimensional trap array (.e., traps clustered space), 2) simulate data different encounter distributions parameters, 3) create habitat masks either raster data spatial polygons, 4) provide template SECR models easily customizable, 5) fit summarize SECR models using ‘nimble’ (de Valpine et . 2022) options parallel processing, 6) create realized density surfaces MCMC output. Future functionality include discrete state-space models implementing localized approaches Milleret et al. (2019) Woodruff et al. (2020).","code":""},{"path":"https://sitkensis22.github.io/localSCR/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Supporting functions for advanced Bayesian spatial capture-recapture modeling using nimble","text":"can install development version ‘localSCR’ like : sure see important information using ‘nimble’ computer (including installing rtools): https://r-nimble.org/download.","code":"library(remotes) install_github(\"sitkensis22/localSCR\")"},{"path":"https://sitkensis22.github.io/localSCR/index.html","id":"vignettes","dir":"","previous_headings":"","what":"Vignettes","title":"Supporting functions for advanced Bayesian spatial capture-recapture modeling using nimble","text":"Classic SCR models: continuous state-space marked individuals","code":""},{"path":"https://sitkensis22.github.io/localSCR/index.html","id":"references","dir":"","previous_headings":"","what":"References","title":"Supporting functions for advanced Bayesian spatial capture-recapture modeling using nimble","text":"de Valpine P, C. Paciorek, D. Turek, N. Michaud, C. Anderson-Bergman, F. Obermeyer, C. C. Wehrhahn, . Rodrìguez, L. D. Temple, S. Paganin. 2022. NIMBLE: MCMC, Particle Filtering, Programmable Hierarchical Modeling. doi: 10.5281/zenodo.1211190 (URL: https://doi.org/10.5281/zenodo.1211190), R package version 0.12.2, URL:https://cran.r-project.org/package=nimble. Milleret, C., P. Dupont, C. Bonenfant, H. Henrik Brøseth, Ø. Flagstad, C. Sutherland, R. Bischof. 2019. local evaluation individual state‐space scale Bayesian spatial capture‐recapture. Ecology Evolution 9:352–363. Royle, J. ., R. B. Chandler, R. Sollmann, B. Gardner. 2014. Spatial capture‐recapture. Academic Press, Waltham, Massachusetts, USA. Woodruff, S., D. R. Eacker, L. Waits. 2020. Estimating coyote density local, discrete Bayesian capture-recapture models. Journal Wildlife Management 10.1002/jwmg.21967","code":""},{"path":"https://sitkensis22.github.io/localSCR/reference/customize_model.html","id":null,"dir":"Reference","previous_headings":"","what":"Function to efficiently edit rows of model code generated from nimble — customize_model","title":"Function to efficiently edit rows of model code generated from nimble — customize_model","text":"Allows efficient editing model code produced nimbleCode()  function","code":""},{"path":"https://sitkensis22.github.io/localSCR/reference/customize_model.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Function to efficiently edit rows of model code generated from nimble — customize_model","text":"","code":"customize_model(   model,   append_code = NULL,   line_append = NULL,   line_remove = NULL,   write = FALSE )"},{"path":"https://sitkensis22.github.io/localSCR/reference/customize_model.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Function to efficiently edit rows of model code generated from nimble — customize_model","text":"model nimbleCode() used define model nimble package, possibly generated get_classic function. append_code either NULL model code produced  nimbleCode()  get_classic function. Note line_remove = NULL, code appended just existing model code; otherwise specify lines insert new code setting  line_append. line_append either NULL integer value scalar vector defining positions insert new lines code model. Note line removal occur first line_remove set, new lines code inserted desired indexing positions. line_remove either NULL integer value scalar vector defining lines code remove model. Set NULL  appending replacing code previous model file. write logical. TRUE, text file written  working directory called \"new_model.txt\". Otherwise, model written temp file deleted. Default FALSE.","code":""},{"path":"https://sitkensis22.github.io/localSCR/reference/customize_model.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Function to efficiently edit rows of model code generated from nimble — customize_model","text":"model description can run nimble using  run_classic.","code":""},{"path":"https://sitkensis22.github.io/localSCR/reference/customize_model.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Function to efficiently edit rows of model code generated from nimble — customize_model","text":"Daniel Eacker","code":""},{"path":"https://sitkensis22.github.io/localSCR/reference/customize_model.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Function to efficiently edit rows of model code generated from nimble — customize_model","text":"","code":"# get model scr_model = get_classic(dim_y = 2, enc_dist = \"binomial\",sex_sigma = TRUE, hab_mask=TRUE,trapsClustered = TRUE)  # create new nimbleCode to use for replacement in 'scr_model' p0_prior = nimble::nimbleCode({    p0[g] ~ dbeta(1,1) })  # replace line 3 of old model code with 'p0_prior'  new_model = customize_model(model = scr_model, append_code = p0_prior,                                     line_append = 3, line_remove = 3)                                     # inspect new model code new_model #> { #>     for (g in 1:nSites) { #>         p0[g] ~ dbeta(1, 1) #>     } #>     psi_sex ~ dunif(0, 1) #>     sigma[1] ~ dunif(0, sigma_upper) #>     sigma[2] ~ dunif(0, sigma_upper) #>     sigma.pixel[1] <- sigma[1]/pixelWidth #>     sigma.pixel[2] <- sigma[2]/pixelWidth #>     psi ~ dunif(0, 1) #>     for (i in 1:M) { #>         sex[i] ~ dbern(psi_sex) #>         sx[i] <- sex[i] + 1 #>         z[i] ~ dbern(psim[i]) #>         psim[i] <- (1 - (1 - psi)^prop.habitat[site[i]]) #>         s[i, 1] ~ dunif(x_lower[site[i]], x_upper[site[i]]) #>         s[i, 2] ~ dunif(y_lower[site[i]], y_upper[site[i]]) #>         pOK[i] <- hab_mask[(trunc(s[i, 2]) + 1), (trunc(s[i,  #>             1]) + 1), site[i]] #>         OK[i] ~ dbern(pOK[i]) #>         dist[i, 1:J] <- sqrt((s[i, 1] - X[1:J, 1, site[i]])^2 +  #>             (s[i, 2] - X[1:J, 2, site[i]])^2) #>         p[i, 1:J] <- p0[site[i]] * exp(-dist[i, 1:J]^2/(2 * sigma.pixel[sx[i]]^2)) #>     } #>     for (i in 1:n0) { #>         for (j in 1:J) { #>             y[i, j] ~ dbin(p[i, j], K) #>         } #>     } #>     for (i in (n0 + 1):M) { #>         zeros[i] ~ dbern((1 - prod(1 - p[i, 1:J])^K) * z[i]) #>     } #>     N <- sum(z[1:M]) #>     D <- N/A #> }"},{"path":"https://sitkensis22.github.io/localSCR/reference/get_classic.html","id":null,"dir":"Reference","previous_headings":"","what":"Function to retrieve nimbleCode for spatial capture-recapture models — get_classic","title":"Function to retrieve nimbleCode for spatial capture-recapture models — get_classic","text":"Creates model code using nimbleCode function.","code":""},{"path":"https://sitkensis22.github.io/localSCR/reference/get_classic.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Function to retrieve nimbleCode for spatial capture-recapture models — get_classic","text":"","code":"get_classic(   dim_y,   enc_dist = \"binomial\",   sex_sigma = FALSE,   hab_mask = FALSE,   trapsClustered = FALSE )"},{"path":"https://sitkensis22.github.io/localSCR/reference/get_classic.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Function to retrieve nimbleCode for spatial capture-recapture models — get_classic","text":"dim_y integer either 2 (default) defines  dimensional format encounter history data . enc_dist either \"binomial\" \"poisson\". Default \"binomial\". sex_sigma logical value indicating whether scaling parameter  ('sigma') sex-specific hab_mask logical value indicating whether habitat mask  used. Default FALSE. trapsClustered logical value indicating traps clustered  arrays across sampling area.","code":""},{"path":"https://sitkensis22.github.io/localSCR/reference/get_classic.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Function to retrieve nimbleCode for spatial capture-recapture models — get_classic","text":"nimbleCode object nimble package.","code":""},{"path":"https://sitkensis22.github.io/localSCR/reference/get_classic.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Function to retrieve nimbleCode for spatial capture-recapture models — get_classic","text":"function provides templates copied easily  modified include model complexity covariates explaining  detection probability. models include different encounter probability  distributions, sex-specific scaling parameters, habitat masking.","code":""},{"path":"https://sitkensis22.github.io/localSCR/reference/get_classic.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Function to retrieve nimbleCode for spatial capture-recapture models — get_classic","text":"Daniel Eacker","code":""},{"path":"https://sitkensis22.github.io/localSCR/reference/get_classic.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Function to retrieve nimbleCode for spatial capture-recapture models — get_classic","text":"","code":"# get model for 2D encounter data, binomial encounter distribution,  # non-sex-specific scaling parameter, and no habitat mask scr_model = get_classic(dim_y = 2,enc_dist = \"binomial\",sex_sigma = FALSE,                          hab_mask = FALSE,trapsClustered = FALSE)  # inspect model scr_model #> { #>     p0 ~ dunif(0, 1) #>     sigma ~ dunif(0, sigma_upper) #>     psi ~ dunif(0, 1) #>     for (i in 1:M) { #>         z[i] ~ dbern(psi) #>         s[i, 1] ~ dunif(x_lower, x_upper) #>         s[i, 2] ~ dunif(y_lower, y_upper) #>         dist[i, 1:J] <- sqrt((s[i, 1] - X[1:J, 1])^2 + (s[i,  #>             2] - X[1:J, 2])^2) #>         p[i, 1:J] <- p0 * exp(-dist[i, 1:J]^2/(2 * sigma^2)) #>     } #>     for (i in 1:n0) { #>         for (j in 1:J) { #>             y[i, j] ~ dbin(p[i, j], K) #>         } #>     } #>     for (i in (n0 + 1):M) { #>         zeros[i] ~ dbern((1 - prod(1 - p[i, 1:J])^K) * z[i]) #>     } #>     N <- sum(z[1:M]) #>     D <- N/A #> }"},{"path":"https://sitkensis22.github.io/localSCR/reference/get_unmarked.html","id":null,"dir":"Reference","previous_headings":"","what":"Function to retrieve nimbleCode for spatial count models — get_unmarked","title":"Function to retrieve nimbleCode for spatial count models — get_unmarked","text":"Creates model code using nimbleCode function.","code":""},{"path":"https://sitkensis22.github.io/localSCR/reference/get_unmarked.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Function to retrieve nimbleCode for spatial count models — get_unmarked","text":"","code":"get_unmarked(   occ_specific = FALSE,   sex_sigma = FALSE,   hab_mask = FALSE,   trapsClustered = FALSE )"},{"path":"https://sitkensis22.github.io/localSCR/reference/get_unmarked.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Function to retrieve nimbleCode for spatial count models — get_unmarked","text":"occ_specific logical. FALSE, encounter rate include occasion-specific loop detection function; otherwise,  model include loop occasions (K) detection function. Default FALSE. sex_sigma logical value indicating whether scaling parameter  ('sigma') sex-specific. hab_mask logical value indicating whether habitat mask  used. Default FALSE. trapsClustered logical value indicating traps clustered  arrays across sampling area.","code":""},{"path":"https://sitkensis22.github.io/localSCR/reference/get_unmarked.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Function to retrieve nimbleCode for spatial count models — get_unmarked","text":"model code created nimbleCode.","code":""},{"path":"https://sitkensis22.github.io/localSCR/reference/get_unmarked.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Function to retrieve nimbleCode for spatial count models — get_unmarked","text":"function provides templates unmarked models can  easily modified include model complexity covariates  explaining detection probability. models include sex-specific scaling  parameters habitat masking.","code":""},{"path":"https://sitkensis22.github.io/localSCR/reference/get_unmarked.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Function to retrieve nimbleCode for spatial count models — get_unmarked","text":"Daniel Eacker","code":""},{"path":"https://sitkensis22.github.io/localSCR/reference/get_unmarked.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Function to retrieve nimbleCode for spatial count models — get_unmarked","text":"","code":"# get spatial count model with non-occasion-specific detection # function, single scaling parameter, no habitat mask, and no clustering unmarked_model = get_unmarked(occ_specific=FALSE,sex_sigma = FALSE,                      hab_mask = FALSE, trapsClustered = FALSE)  # inspect model unmarked_model #> { #>     lam0 ~ dunif(0, lam0_upper) #>     sigma ~ dunif(0, sigma_upper) #>     psi ~ dunif(0, 1) #>     for (i in 1:M) { #>         zu[i] ~ dbern(psi) #>         su[i, 1] ~ dunif(x_lower, x_upper) #>         su[i, 2] ~ dunif(y_lower, y_upper) #>         dist[i, 1:J] <- sqrt((su[i, 1] - X[1:J, 1])^2 + (su[i,  #>             2] - X[1:J, 2])^2) #>         lam[i, 1:J] <- lam0 * exp(-dist[i, 1:J]^2/(2 * sigma^2)) *  #>             zu[i] #>     } #>     for (j in 1:J) { #>         bigLambda[j] <- sum(lam[1:M, j]) #>         for (k in 1:K) { #>             n[j, k] ~ dpois(bigLamda[j]) #>         } #>     } #>     N <- sum(zu[1:M]) #>     D <- N/A #> }"},{"path":"https://sitkensis22.github.io/localSCR/reference/grid_classic.html","id":null,"dir":"Reference","previous_headings":"","what":"Function to define state-space for spatial capture-recapture models — grid_classic","title":"Function to define state-space for spatial capture-recapture models — grid_classic","text":"Returns list matrix array object grid coordinates Extent object raster package  state-space.","code":""},{"path":"https://sitkensis22.github.io/localSCR/reference/grid_classic.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Function to define state-space for spatial capture-recapture models — grid_classic","text":"","code":"grid_classic(X, crs_, buff, res)"},{"path":"https://sitkensis22.github.io/localSCR/reference/grid_classic.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Function to define state-space for spatial capture-recapture models — grid_classic","text":"X either matrix array representing coordinates traps UTMs. array used traps clustered survey area. crs_ UTM coordinate reference system (EPSG code) used location provided integer (e.g., 32608 WGS 84/UTM Zone 8N). buff distance (m km) traps buffered integer. typically 3 times sigma parameter. res grid cell resolution state-space.","code":""},{"path":"https://sitkensis22.github.io/localSCR/reference/grid_classic.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Function to define state-space for spatial capture-recapture models — grid_classic","text":"list matrix array grid coordinates grid extent object ext. Note matrix object returned  coordinates traps matrix (.e., 2D), otherwise array object returned trap coordinates 3D array.","code":""},{"path":"https://sitkensis22.github.io/localSCR/reference/grid_classic.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Function to define state-space for spatial capture-recapture models — grid_classic","text":"function supports spatial capture-recapture analysis creating two outputs used define state-space. habitat  mask used, Extent object raster package needed uniform state-space. matrix array object can used develop habitat mask uniform state-space discretized state-space.","code":""},{"path":[]},{"path":"https://sitkensis22.github.io/localSCR/reference/grid_classic.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Function to define state-space for spatial capture-recapture models — grid_classic","text":"Daniel Eacker","code":""},{"path":"https://sitkensis22.github.io/localSCR/reference/grid_classic.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Function to define state-space for spatial capture-recapture models — grid_classic","text":"","code":"# simulate a single trap array with random positional noise x <- seq(-800, 800, length.out = 5) y <- seq(-800, 800, length.out = 5) traps <- as.matrix(expand.grid(x = x, y = y)) # add some random noise to locations traps <- traps + runif(prod(dim(traps)),-20,20)  mysigma = 300 # simulate sigma of 300 m mycrs = 32608 # EPSG for WGS 84 / UTM zone 8N  # create state-space Grid = grid_classic(X = traps, crs_ = mycrs, buff = 3*mysigma, res = 100)  # make plot of grid and trap locations par(mfrow=c(1,1)) plot(Grid$grid, pch=19) points(traps, col=\"blue\",pch=20)"},{"path":"https://sitkensis22.github.io/localSCR/reference/initialize_classic.html","id":null,"dir":"Reference","previous_headings":"","what":"Function to generate starting locations for activity centers — initialize_classic","title":"Function to generate starting locations for activity centers — initialize_classic","text":"Generate matrix intial starting locations, possibly accounting  habitat mask.","code":""},{"path":"https://sitkensis22.github.io/localSCR/reference/initialize_classic.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Function to generate starting locations for activity centers — initialize_classic","text":"","code":"initialize_classic(y, M, X, buff, site, hab_mask, all_random = FALSE)"},{"path":"https://sitkensis22.github.io/localSCR/reference/initialize_classic.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Function to generate starting locations for activity centers — initialize_classic","text":"y either matrix array encounter history data, possiblity  sim_classic(). M integer total augmented population size (.e., detected  augmented individuals). UTMs. array used traps clustered  survey area. X either matrix array representing coordinates traps UTMs. array used traps clustered survey area. buff distance (m km) traps buffered integer. typically 3 times sigma parameter. site Either NULL (2D trap array used) vector  integers denoting trap array individual (either detected  augmented) belongs . Note site provided  sim_classic 3D trap array used. However,  site variable must correctly augmented based total   augmented population size (.e., M). hab_mask either FALSE (default) matrix array output mask_polygon mask_raster functions. all_random logical. TRUE, encounter data y  ignored initial activity center starting locations randomly chosen. FALSE (default), initial values mean capture  location detected individuals random locations augmented individuals.","code":""},{"path":"https://sitkensis22.github.io/localSCR/reference/initialize_classic.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Function to generate starting locations for activity centers — initialize_classic","text":"matrix initial activity center coordinates M rows  2 columns.","code":""},{"path":"https://sitkensis22.github.io/localSCR/reference/initialize_classic.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Function to generate starting locations for activity centers — initialize_classic","text":"function generates initial activity center locations based  encounter histories, augmented population size, state-space buffer,  potentially habitat mask. Note mean trap detection locations  used detected individuals intial values randomly drawn  augemented individuals. Also, habitat check conducted  locations habitat mask included.","code":""},{"path":"https://sitkensis22.github.io/localSCR/reference/initialize_classic.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Function to generate starting locations for activity centers — initialize_classic","text":"Daniel Eacker","code":""},{"path":"https://sitkensis22.github.io/localSCR/reference/initialize_classic.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Function to generate starting locations for activity centers — initialize_classic","text":"","code":"# simulate a single trap array with random positional noise x <- seq(-800, 800, length.out = 5) y <- seq(-800, 800, length.out = 5) traps <- as.matrix(expand.grid(x = x, y = y))  # add some random noise to locations traps <- traps + runif(prod(dim(traps)),-20,20)   mysigma = 300 # simulate sigma of 300 m mycrs = 32608 # EPSG for WGS 84 / UTM zone 8N  # Create grid and extent Grid = grid_classic(X = traps, crs_ = mycrs, buff = 3*mysigma, res = 100)  # simulate SCR data data3d = sim_classic(X = traps, ext = Grid$ext, crs_ = mycrs,  sigma_ = mysigma, prop_sex = 1, N = 200, K = 4, base_encounter = 0.25,  enc_dist = \"binomial\", hab_mask = FALSE, setSeed = 50)  # generate initial activity center coordinates for 2D trap array without  # habitat mask s.st3d = initialize_classic(y=data3d$y, M=500, X=traps, buff = 3*mysigma,  hab_mask = FALSE, all_random = FALSE)  # make simple plot par(mfrow=c(1,1)) plot(Grid$grid, pch=20,ylab=\"Northing\",xlab=\"Easting\") points(traps, col=\"blue\",pch=20) points(s.st3d, col=\"red\",pch=20)"},{"path":"https://sitkensis22.github.io/localSCR/reference/mask_polygon.html","id":null,"dir":"Reference","previous_headings":"","what":"Function to create habitat mask matrix or array from polygon — mask_polygon","title":"Function to create habitat mask matrix or array from polygon — mask_polygon","text":"Creates matrix array use habitat mask account unsuitable  habitat.","code":""},{"path":"https://sitkensis22.github.io/localSCR/reference/mask_polygon.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Function to create habitat mask matrix or array from polygon — mask_polygon","text":"","code":"mask_polygon(poly, grid, crs_, prev_mask)"},{"path":"https://sitkensis22.github.io/localSCR/reference/mask_polygon.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Function to create habitat mask matrix or array from polygon — mask_polygon","text":"poly polygon created using sf package class  \"sfc_POLYGON\" grid matrix array object state-space grid.  returned grid_classic. crs_ UTM coordinate reference system (EPSG code) used location provided integer (e.g., 32608 WGS 84/UTM Zone 8N). prev_mask either NULL previously created habitat mask  matrix array mask_polygon mask_raster.  allows habitat masks combined account different  spatial features.","code":""},{"path":"https://sitkensis22.github.io/localSCR/reference/mask_polygon.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Function to create habitat mask matrix or array from polygon — mask_polygon","text":"matrix array 0's 1's denoting unsuitable suitable  habitat respectively.","code":""},{"path":"https://sitkensis22.github.io/localSCR/reference/mask_polygon.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Function to create habitat mask matrix or array from polygon — mask_polygon","text":"function creates habitat matrix array depending upon  whether 2D (former) 3D (latter) trap array used. matrix can  directly included data Bayesian SCR models run using nimble.","code":""},{"path":[]},{"path":"https://sitkensis22.github.io/localSCR/reference/mask_polygon.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Function to create habitat mask matrix or array from polygon — mask_polygon","text":"Daniel Eacker","code":""},{"path":"https://sitkensis22.github.io/localSCR/reference/mask_polygon.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Function to create habitat mask matrix or array from polygon — mask_polygon","text":"","code":"# simulate a single trap array with random positional noise x <- seq(-800, 800, length.out = 5) y <- seq(-800, 800, length.out = 5) traps <- as.matrix(expand.grid(x = x, y = y))  # add some random noise to locations traps <- traps + runif(prod(dim(traps)),-20,20)   mysigma = 300 # simulate sigma of 300 m mycrs = 32608 # EPSG for WGS 84 / UTM zone 8N  # create state-space grid and extent Grid = grid_classic(X = traps, crs_ = mycrs, buff = 3*mysigma, res = 100)  # create polygon to use as a mask library(sf) #> Linking to GEOS 3.8.0, GDAL 3.0.4, PROJ 6.3.1; sf_use_s2() is TRUE poly = st_sfc(st_polygon(x=list(matrix(c(-1765,-1765,1730,-1650,1600,1650, 0,1350,-800,1700,-1850,1000,-1765,-1765),ncol=2, byrow=TRUE))), crs =  mycrs)  # make simple plot par(mfrow=c(1,2)) plot(Grid$grid, pch=20) points(traps, col=\"blue\",pch=20) plot(poly, add=TRUE)  # create habitat mask from polygon hab_mask = mask_polygon(poly = poly, grid = Grid$grid, crs_ = mycrs,  prev_mask = NULL)  # make simple plot library(raster) #> Loading required package: sp plot(raster(apply(hab_mask,2,rev)))  # make simple plot poly2 = st_sfc(st_polygon(x=list(matrix(c(-1365,-1365,1730,-1650,1500,1550, 0,1350,-800,1700,-1850,1000,-1365,-1365),ncol=2, byrow=TRUE))), crs =  mycrs) plot(poly2, add=TRUE)   # mask second polygon, building on previous habitat mask hab_mask2 = mask_polygon(poly = poly2, grid = Grid$grid, crs_ = mycrs,  prev_mask = hab_mask)  # make simple plot plot(Grid$grid, pch=20) points(traps, col=\"blue\",pch=20) plot(poly, add=TRUE) plot(poly2, add=TRUE) plot(raster(apply(hab_mask2,2,rev)))   # create an array of traps, as an approach where individuals will only be  # detected at one of the trap arrays (e.g., Furnas et al. 2018) Xarray = array(NA, dim=c(nrow(traps),2,2)) Xarray[,,1]=traps Xarray[,,2]=traps+4000 # shift trapping grid to new locations  # Example of using habitat mask with 3D trap array (need polygon that  # masks both trapping extents) GridX = grid_classic(X = Xarray, crs_ = mycrs, buff = 3*mysigma, res = 100)  # make simple plot par(mfrow=c(1,1)) plot(GridX$grid[,,1],xlim=c(-1600,6000),ylim=c(-1600,6000),col=\"darkgrey\", pch=20,ylab=\"Northing\",xlab=\"Easting\") points(Xarray[,,1],col=\"blue\",pch=20) points(GridX$grid[,,2],pch=20,col=\"darkgrey\") points(Xarray[,,2],col=\"blue\",pch=20)  poly = st_sfc(st_polygon(x=list(matrix(c(-1660,-1900,5730,-1050,5470,5150, 0,6050,-1800,5700,-1660,-1900),ncol=2, byrow=TRUE))), crs =  mycrs) plot(poly, add=TRUE)   # get 3D habitat mask array for 3D grid hab_mask = mask_polygon(poly = poly, grid = GridX$grid, crs_ = mycrs,  prev_mask = NULL)  # make simple plot par(mfrow=c(1,2)) apply(hab_mask,3,function(x) plot(raster(apply(x,2,rev))))  #> NULL"},{"path":"https://sitkensis22.github.io/localSCR/reference/mask_raster.html","id":null,"dir":"Reference","previous_headings":"","what":"Function to create habitat mask matrix or array from raster — mask_raster","title":"Function to create habitat mask matrix or array from raster — mask_raster","text":"Creates matrix array use habitat mask account unsuitable  habitat.","code":""},{"path":"https://sitkensis22.github.io/localSCR/reference/mask_raster.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Function to create habitat mask matrix or array from raster — mask_raster","text":"","code":"mask_raster(rast, FUN, grid, crs_, prev_mask)"},{"path":"https://sitkensis22.github.io/localSCR/reference/mask_raster.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Function to create habitat mask matrix or array from raster — mask_raster","text":"rast raster layer created using raster package class  \"RasterLayer\" FUN function defines criteria suitable habitat. grid matrix array object state-space grid.  returned grid_classic. crs_ UTM coordinate reference system (EPSG code) used location provided integer (e.g., 32608 WGS 84/UTM Zone 8N). prev_mask either NULL previously created habitat mask  matrix array mask_polygon mask_raster.  allows habitat masks combined account different spatial  features.","code":""},{"path":"https://sitkensis22.github.io/localSCR/reference/mask_raster.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Function to create habitat mask matrix or array from raster — mask_raster","text":"matrix array 0's 1's denoting unsuitable suitable  habitat respectively.","code":""},{"path":"https://sitkensis22.github.io/localSCR/reference/mask_raster.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Function to create habitat mask matrix or array from raster — mask_raster","text":"function creates habitat matrix array depending upon  whether 2D (former) 3D (latter) trap array used. matrix can  directly included data Bayesian SCR models run using nimble.","code":""},{"path":[]},{"path":"https://sitkensis22.github.io/localSCR/reference/mask_raster.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Function to create habitat mask matrix or array from raster — mask_raster","text":"Daniel Eacker","code":""},{"path":"https://sitkensis22.github.io/localSCR/reference/mask_raster.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Function to create habitat mask matrix or array from raster — mask_raster","text":"","code":"# simulate a single trap array with random positional noise x <- seq(-800, 800, length.out = 5) y <- seq(-800, 800, length.out = 5) traps <- as.matrix(expand.grid(x = x, y = y))   # add some random noise to locations traps <- traps + runif(prod(dim(traps)),-20,20)  mysigma = 300 # simulate sigma of 300 m mycrs = 32608 # EPSG for WGS 84 / UTM zone 8N  # create state-space grid and extent Grid = grid_classic(X = traps, crs_ = mycrs, buff = 3*mysigma, res = 100)  # run previous code used for mask_polygon() to create raster for example library(sf) poly = st_sfc(st_polygon(x=list(matrix(c(-1665,-1665,1730,-1650,1600,1650, 0,1350,-800,1700,-1850,1000,-1665,-1665),ncol=2, byrow=TRUE))), crs =  mycrs) hab_mask = mask_polygon(poly = poly, grid = Grid$grid, crs_ = mycrs,  prev_mask = NULL)  # create raster for demonstration purposes library(raster) rast <- raster(nrow=dim(hab_mask)[1], ncol=dim(hab_mask)[2],ext=Grid$ext, crs=mycrs) rast[] = apply(hab_mask,2,rev)  # create habitat mask using raster hab_mask_r = mask_raster(rast = rast, FUN = function(x){x==1},  grid = Grid$grid, crs_ = mycrs, prev_mask = NULL) #> Error in mask_raster(rast = rast, FUN = function(x) {    x == 1}, grid = Grid$grid, crs_ = mycrs, prev_mask = NULL): crs of raster layer must be the same as crs_  # make simple plot # returns identical results as input rast (but this was just an example raster) plot(raster(apply(hab_mask_r,2,rev)))  #> Error in h(simpleError(msg, call)): error in evaluating the argument 'x' in selecting a method for function 'plot': error in evaluating the argument 'x' in selecting a method for function 'raster': object 'hab_mask_r' not found  # create an array of traps, as an approach where individuals will only be  # detected at one of the trap arrays (e.g., Furnas et al. 2018) Xarray = array(NA, dim=c(nrow(traps),2,2)) Xarray[,,1]=traps Xarray[,,2]=traps+4000 # shift trapping grid to new locations  # create grid and extent for 3D trap array GridX = grid_classic(X = Xarray, crs_ = mycrs, buff = 3*mysigma, res = 100)  # make simple plot par(mfrow=c(1,1)) plot(GridX$grid[,,1],xlim=c(-1600,6000),ylim=c(-1600,6000),col=\"darkgrey\", pch=20,ylab=\"Northing\",xlab=\"Easting\") points(Xarray[,,1],col=\"blue\",pch=20) points(GridX$grid[,,2],pch=20,col=\"darkgrey\") points(Xarray[,,2],col=\"blue\",pch=20)  # create polygon to use as a mask and covert to raster poly = st_sfc(st_polygon(x=list(matrix(c(-1660,-1900,5730,-1050,5470,5650, 0,6050,-1800,5700,-1660,-1900),ncol=2, byrow=TRUE))), crs =  mycrs)  # add polygon to plot plot(poly, add=TRUE)   # make raster from polygon rast = raster(xmn=-2000, xmx=6000, ymn=-2000, ymx=6500,res=100,crs=mycrs) rast[]=st_intersects(st_cast(st_sfc(st_multipoint(coordinates(rast)),  crs =  mycrs),\"POINT\"),poly,sparse=FALSE)  # make simple plot of raster plot(rast)   # get 3D habitat mask array for 3D grid hab_mask = mask_raster(rast = rast, FUN = function(x){x==1},grid = GridX$grid,  crs_ = mycrs, prev_mask = NULL) #> Error in mask_raster(rast = rast, FUN = function(x) {    x == 1}, grid = GridX$grid, crs_ = mycrs, prev_mask = NULL): crs of raster layer must be the same as crs_ par(mfrow=c(1,2)) apply(hab_mask,3,function(x) plot(raster(apply(x,2,rev)))) #> Error in apply(hab_mask, 3, function(x) plot(raster(apply(x, 2, rev)))): 'MARGIN' does not match dim(X)"},{"path":"https://sitkensis22.github.io/localSCR/reference/nimSummary.html","id":null,"dir":"Reference","previous_headings":"","what":"Function to summarize MCMC chain output from nimble — nimSummary","title":"Function to summarize MCMC chain output from nimble — nimSummary","text":"Summarizes lists MCMC chain output nimble","code":""},{"path":"https://sitkensis22.github.io/localSCR/reference/nimSummary.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Function to summarize MCMC chain output from nimble — nimSummary","text":"","code":"nimSummary(   d,   trace = FALSE,   plot_all = FALSE,   exclude_params = NULL,   digits = 3 )"},{"path":"https://sitkensis22.github.io/localSCR/reference/nimSummary.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Function to summarize MCMC chain output from nimble — nimSummary","text":"d list MCMC samples chain returned  run_classic. trace logical value indicating whether traces MCMC samples plotted. Default FALSE. plot_all logical value indicating whether parameters  included plots. assumes parameters excluded summary table (.e., exclude_params != NULL).  Default FALSE. exclude_params either NULL scalar vector containing  parameter(s) exclude summary. Note high dimensional parameters  (e.g., s[1, 1, 1]) can excluded calling exclude_params =   \"s\". Default NULL. digits integer value indicating many digits output  rounded .","code":""},{"path":"https://sitkensis22.github.io/localSCR/reference/nimSummary.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Function to summarize MCMC chain output from nimble — nimSummary","text":"dataframe summary statistics MCMC samples.","code":""},{"path":"https://sitkensis22.github.io/localSCR/reference/nimSummary.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Function to summarize MCMC chain output from nimble — nimSummary","text":"function summarizes Bayesian SCR models run using nimble  including mean quantiles samples, well effective sample size  Rhat statistics. Note f0 proportion samples   greater zero. Also, least 2 chains must run use function.","code":""},{"path":"https://sitkensis22.github.io/localSCR/reference/nimSummary.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Function to summarize MCMC chain output from nimble — nimSummary","text":"Daniel Eacker","code":""},{"path":"https://sitkensis22.github.io/localSCR/reference/nimSummary.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Function to summarize MCMC chain output from nimble — nimSummary","text":"","code":"if (FALSE) { # simulate a single trap array with random positional noise x <- seq(-800, 800, length.out = 5) y <- seq(-800, 800, length.out = 5) traps <- as.matrix(expand.grid(x = x, y = y))  # add some random noise to locations traps <- traps + runif(prod(dim(traps)),-20,20)   mysigma = 300 # simulate sigma of 300 m mycrs = 32608 # EPSG for WGS 84 / UTM zone 8N pixelWidth = 100 # store pixelWidth  # create grid and extent Grid = grid_classic(X = traps, crs_ = mycrs, buff = 3*mysigma,  res = pixelWidth)  # simulate encounter data data3d = sim_classic(X = traps, ext = Grid$ext, crs_ = mycrs, sigma = mysigma,  prop_sex = 1, N = 200, K = 4, base_encounter = 0.15, enc_dist = \"binomial\",  hab_mask = FALSE, setSeed = 200)  # prepare data data = list(y=data3d$y) data$y = data$y[which(apply(data$y, 1, sum)!=0),,] # remove augmented records data$y = apply(data$y, c(1,2), sum) # covert to 2d by summing over occasions data$X = traps/1000 # rescale to kilometers ext = as.vector(Grid$ext)/1000 # recale to kilometers  # prepare constants constants = list(M = 500,n0 = nrow(data$y),J=dim(data$y)[2],              K=dim(data3d$y)[3],x_lower = ext[1], x_upper = ext[2],             y_lower = ext[3], y_upper = ext[4],sigma_upper = 1,             A = prod(ext[2]-ext[1],ext[4]-ext[3]))  # add z and zeros vector data for latent inclusion indicator data$z = c(rep(1,constants$n0),rep(NA,constants$M - constants$n0)) data$zeros =  c(rep(NA,constants$n0),rep(0,constants$M - constants$n0))  # get initial activity center starting values s.st3d = initialize_classic(y=data3d$y, M=500, X=traps, buff = 3*mysigma,  hab_mask=FALSE)  # define all initial values inits = list(sigma = runif(1, 0.250, 0.350), s = s.st3d/1000,              psi=runif(1,0.2,0.3), p0 = runif(1, 0.05, 0.15),              z=c(rep(NA,constants$n0),rep(0,constants$M-constants$n0)))  # parameters to monitor params = c(\"sigma\",\"psi\",\"p0\",\"N\",\"D\")  # get model scr_model = get_classic(dim_y = 2, enc_dist = \"binomial\",sex_sigma = FALSE)  # run model library(tictoc) tic() # track time elapsed out = run_classic(model = scr_model, data=data, constants=constants,                    inits=inits, params = params,niter = 5000, nburnin=1000,                   thin=1, nchains=2, parallel=TRUE, RNGseed = 500) toc()  # summarize output samples = do.call(rbind, out) par(mfrow=c(1,1)) hist(samples[,which(dimnames(out[[1]])[[2]]==\"N\")], xlab = \"Abundance\",  xlim = c(0,500), main=\"\") abline(v=200, col=\"red\") # add line for simulated abundance  # summarize output nimSummary(out, trace=TRUE, plot_all=TRUE) }"},{"path":"https://sitkensis22.github.io/localSCR/reference/realized_density.html","id":null,"dir":"Reference","previous_headings":"","what":"Function to generate realized density surface from MCMC output — realized_density","title":"Function to generate realized density surface from MCMC output — realized_density","text":"Streamlined construction realized density surface posterior samples latent indicator variable (z) activity center coordinates (s)","code":""},{"path":"https://sitkensis22.github.io/localSCR/reference/realized_density.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Function to generate realized density surface from MCMC output — realized_density","text":"","code":"realized_density(   samples,   grid,   crs_,   site,   hab_mask,   s_alias = \"s\",   z_alias = \"z\" )"},{"path":"https://sitkensis22.github.io/localSCR/reference/realized_density.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Function to generate realized density surface from MCMC output — realized_density","text":"samples either matrix (single MCMC chain) list posterior samples multiple chains MCMC sampling; possibly returned  run_classic. grid matrix array object state-space grid.  returned grid_classic. crs_ UTM coordinate reference system (EPSG code) used location provided integer (e.g., 32608 WGS 84/UTM Zone 8N). site site indentifier variable included detected augmented  individuals used constant model runs. hab_mask either FALSE (default) matrix arary  output mask_polygon mask_raster functions. s_alias character value used identify latent activity center  coordinates used model. Default \"s\". z_alias character value used identify latent inclusion  indicator used model. Default \"z\".","code":""},{"path":"https://sitkensis22.github.io/localSCR/reference/realized_density.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Function to generate realized density surface from MCMC output — realized_density","text":"raster object list raster objects  state-space grid array.","code":""},{"path":"https://sitkensis22.github.io/localSCR/reference/realized_density.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Function to generate realized density surface from MCMC output — realized_density","text":"function automates construction realized density  surfaces MCMC samples.","code":""},{"path":"https://sitkensis22.github.io/localSCR/reference/realized_density.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Function to generate realized density surface from MCMC output — realized_density","text":"Daniel Eacker","code":""},{"path":"https://sitkensis22.github.io/localSCR/reference/realized_density.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Function to generate realized density surface from MCMC output — realized_density","text":"","code":"if (FALSE) { # simulate a single trap array with random positional noise x <- seq(-800, 800, length.out = 5) y <- seq(-800, 800, length.out = 5) traps <- as.matrix(expand.grid(x = x, y = y))  # add some random noise to locations traps <- traps + runif(prod(dim(traps)),-20,20)   mysigma = 300 # simulate sigma of 300 m mycrs = 32608 # EPSG for WGS 84 / UTM zone 8N pixelWidth = 100 # store pixelWidth  # create grid and extent Grid = grid_classic(X = traps, crs_ = mycrs, buff = 3*mysigma,  res = pixelWidth)  # simulate encounter data data3d = sim_classic(X = traps, ext = Grid$ext, crs_ = mycrs, sigma = mysigma,  prop_sex = 1, N = 200, K = 4, base_encounter = 0.15, enc_dist = \"binomial\",  hab_mask = FALSE, setSeed = 200)  # prepare data data = list(y=data3d$y) data$y = data$y[which(apply(data$y, 1, sum)!=0),,] # remove augmented records data$y = apply(data$y, c(1,2), sum) # covert to 2d by summing over occasions data$X = traps # rescale to kilometers ext = as.vector(Grid$ext) # recale to kilometers  # prepare constants constants = list(M = 500,n0 = nrow(data$y),J=dim(data$y)[2],              K=dim(data3d$y)[3],x_lower = ext[1], x_upper = ext[2],              y_lower = ext[3], y_upper = ext[4],sigma_upper = 1000,              A = prod(ext[2]-ext[1],ext[4]-ext[3]))  # add z and zeros vector data for latent inclusion indicator data$z = c(rep(1,constants$n0),rep(NA,constants$M - constants$n0)) data$zeros =  c(rep(NA,constants$n0),rep(0,constants$M - constants$n0))  # get initial activity center starting values s.st3d = initialize_classic(y=data3d$y, M=500, X=traps, buff = 3*mysigma,  hab_mask=FALSE)  # define all initial values inits = list(sigma = runif(1, 250, 350), s = s.st3d,psi=runif(1,0.2,0.3),          p0 = runif(1, 0.05, 0.15),          z=c(rep(NA,constants$n0),rep(0,constants$M-constants$n0)))  # parameters to monitor params = c(\"sigma\",\"psi\",\"p0\",\"N\",\"D\",\"s\",\"z\")  # get model scr_model = get_classic(dim_y = 2, enc_dist = \"binomial\",sex_sigma = FALSE, trapsClustered = FALSE)  # run model library(tictoc()) tic() # track time elapsed out = run_classic(model = scr_model, data=data, constants=constants,           inits=inits, params = params, niter = 5000, nburnin=1000,           thin=1, nchains=2, parallel=TRUE, RNGseed = 500) toc()  # summarize output (exclude lengthy parameters \"s\" and \"z\") nimSummary(out, exclude_params = c(\"s\",\"z\"), trace = TRUE)  library(tictoc)        tic() # track time r = realized_density(samples = out, grid = Grid$grid, crs_ = mycrs,  site = NULL, hab_mask = FALSE)        toc()        # load virdiis color pallete library       library(viridis) library(raster)  # make simple raster plot label = expression(\"Realized density (activity centers/100 m\"^2*\")\") plot(r, col=viridis(100),main=label) }"},{"path":"https://sitkensis22.github.io/localSCR/reference/rescale_classic.html","id":null,"dir":"Reference","previous_headings":"","what":"Function to rescale trap coordinates, grid extent, and starting activity \ncenter coordinates — rescale_classic","title":"Function to rescale trap coordinates, grid extent, and starting activity \ncenter coordinates — rescale_classic","text":"Rescale inputs prepare data habitat mask used.","code":""},{"path":"https://sitkensis22.github.io/localSCR/reference/rescale_classic.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Function to rescale trap coordinates, grid extent, and starting activity \ncenter coordinates — rescale_classic","text":"","code":"rescale_classic(X, ext, s.st, site, hab_mask)"},{"path":"https://sitkensis22.github.io/localSCR/reference/rescale_classic.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Function to rescale trap coordinates, grid extent, and starting activity \ncenter coordinates — rescale_classic","text":"X either matrix array representing coordinates traps UTMs. array used traps clustered survey area. ext Extent object raster package.  returned grid_classic. s.st matrix starting activity center coordinates.  returned initialize_classic buffered integer. typically 3 times sigma parameter. site Either NULL (2D trap array used) vector  integers denoting trap array individual (either detected  augmented) belongs . Note site provided  sim_classic 3D trap array used. However,  site variable must correctly augmented based total  augmented population size (.e., M). hab_mask matrix arary output mask_polygon mask_raster functions.","code":""},{"path":"https://sitkensis22.github.io/localSCR/reference/rescale_classic.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Function to rescale trap coordinates, grid extent, and starting activity \ncenter coordinates — rescale_classic","text":"list rescaled trap coordinates, grid extents, starting  activity center coordinates.","code":""},{"path":"https://sitkensis22.github.io/localSCR/reference/rescale_classic.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Function to rescale trap coordinates, grid extent, and starting activity \ncenter coordinates — rescale_classic","text":"function meant used habitat masking  incorporated model. functions properly rescales inputs based  dimensions habitat mask. Note pixelWidth needs  included input model inputs rescaled correctly  estimate scaling parameter (.e., 'sigma').","code":""},{"path":[]},{"path":"https://sitkensis22.github.io/localSCR/reference/rescale_classic.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Function to rescale trap coordinates, grid extent, and starting activity \ncenter coordinates — rescale_classic","text":"Daniel Eacker","code":""},{"path":"https://sitkensis22.github.io/localSCR/reference/rescale_classic.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Function to rescale trap coordinates, grid extent, and starting activity \ncenter coordinates — rescale_classic","text":"","code":"# simulate a single trap array with random positional noise x <- seq(-800, 800, length.out = 5) y <- seq(-800, 800, length.out = 5) traps <- as.matrix(expand.grid(x = x, y = y))  # add some random noise to locations traps <- traps + runif(prod(dim(traps)),-20,20)   mysigma = 300 # simulate sigma of 300 m mycrs = 32608 # EPSG for WGS 84 / UTM zone 8N  # create grid Grid = grid_classic(X = traps, crs_ = mycrs, buff = 3*mysigma, res = 100)  # create polygon to use as a mask library(sf) poly = st_sfc(st_polygon(x=list(matrix(c(-1765,-1765,1730,-1650,1600,1650, 0,1350,-800,1700,-1850,1000,-1765,-1765),ncol=2, byrow=TRUE))), crs =  mycrs)  # make simple plot par(mfrow=c(1,1)) plot(Grid$grid, pch=20) points(traps, col=\"blue\",pch=20) plot(poly, add=TRUE)   # create habitat mask hab_mask = mask_polygon(poly = poly, grid = Grid$grid, crs_ = mycrs,  prev_mask = NULL)  # simulate SCR data data3d = sim_classic(X = traps, ext = Grid$ext, crs_ = mycrs,  sigma_ = mysigma, prop_sex = 1, N = 200, K = 4, base_encounter = 0.25,  enc_dist = \"binomial\", hab_mask = hab_mask, setSeed = 50)  # generate initial activity center coordinates for 2D trap array without  #habitat mask s.st3d = initialize_classic(y=data3d$y, M=500, X=traps, buff = 3*mysigma,  hab_mask = hab_mask)  # build rescaled constants list for 2D trap array constList = rescale_classic(X = traps, ext = Grid$ext, s.st = s.st3d,  site = NULL, hab_mask = hab_mask) str(constList) #> List of 3 #>  $ X   : num [1:25, 1:2] 9.03 13.19 16.94 20.82 24.84 ... #>   ..- attr(*, \"dimnames\")=List of 2 #>   .. ..$ : NULL #>   .. ..$ : chr [1:2] \"x\" \"y\" #>  $ ext :Formal class 'Extent' [package \"raster\"] with 4 slots #>   .. ..@ xmin: num 0 #>   .. ..@ xmax: num 34 #>   .. ..@ ymin: num 0 #>   .. ..@ ymax: num 34 #>  $ s.st: num [1:500, 1:2] 13.1 10.5 18.3 21.8 22.3 ..."},{"path":"https://sitkensis22.github.io/localSCR/reference/run_classic.html","id":null,"dir":"Reference","previous_headings":"","what":"Function to run spatial capture-recapture models in nimble using \nparallel processing — run_classic","title":"Function to run spatial capture-recapture models in nimble using \nparallel processing — run_classic","text":"wrapper function conduct Markov Chain Monte Carlo (MCMC) sampling using  nimble.","code":""},{"path":"https://sitkensis22.github.io/localSCR/reference/run_classic.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Function to run spatial capture-recapture models in nimble using \nparallel processing — run_classic","text":"","code":"run_classic(   model,   data,   constants,   inits,   params,   niter = 1000,   nburnin = 100,   thin = 1,   nchains = 1,   parallel = FALSE,   RNGseed = NULL,   s_alias = \"s\" )"},{"path":"https://sitkensis22.github.io/localSCR/reference/run_classic.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Function to run spatial capture-recapture models in nimble using \nparallel processing — run_classic","text":"model nimbleCode used define model nimble package, possibly generated get_classic. data list data inputs needed run SCR models nimble. constants list constants needed run SCR models nimble. inits starting values stochastic parameters begin MCMC sampling. params vector character strings define parameters  trace MCMC simulation. niter integer value total number MCMC iterations run  per chain. nburnin integer value number MCMC iterations discard  'burnin'. thin integer value amount thinning chain.  example, thin=2 retain every MCMC sample. nchains integer value number MCMC chains run parallel logical value indicating whether MCMC chains shoud run  parallel processing. Default FALSE. RNGseed integer value specifying random number generating seed  using parallel processing.  ensures MCMC samples run using  data, etc. Default NULL. s_alias character value used identify latent activity center coordinates used model. Default \"s\". Note length s_alias must either 1 (e.g., \"s\") 2  (e.g., c(\"s\",\"su\")).","code":""},{"path":"https://sitkensis22.github.io/localSCR/reference/run_classic.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Function to run spatial capture-recapture models in nimble using \nparallel processing — run_classic","text":"list MCMC samples parameter traced length equal  number chains run.","code":""},{"path":"https://sitkensis22.github.io/localSCR/reference/run_classic.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Function to run spatial capture-recapture models in nimble using \nparallel processing — run_classic","text":"function provides wrapper easily run Bayesian SCR models  using nimble.","code":""},{"path":"https://sitkensis22.github.io/localSCR/reference/run_classic.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Function to run spatial capture-recapture models in nimble using \nparallel processing — run_classic","text":"Daniel Eacker","code":""},{"path":"https://sitkensis22.github.io/localSCR/reference/run_classic.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Function to run spatial capture-recapture models in nimble using \nparallel processing — run_classic","text":"","code":"if (FALSE) { # simulate a single trap array with random positional noise x <- seq(-800, 800, length.out = 5) y <- seq(-800, 800, length.out = 5) traps <- as.matrix(expand.grid(x = x, y = y))  # add some random noise to locations traps <- traps + runif(prod(dim(traps)),-20,20)   mysigma = 300 # simulate sigma of 300 m mycrs = 32608 # EPSG for WGS 84 / UTM zone 8N pixelWidth = 100 # store pixelWidth  Grid = grid_classic(X = traps, crs_ = mycrs, buff = 3*mysigma,  res = pixelWidth) # create slightly larger buffer area for example  # create polygon to use as a mask library(sf) poly = st_sfc(st_polygon(x=list(matrix(c(-1765,-1765,1730,-1650,1600,1650, 0,1350,-800,1700,-1850,1000,-1765,-1765),ncol=2, byrow=TRUE))), crs =  mycrs)  # create habitat mask hab_mask = mask_polygon(poly = poly, grid = Grid$grid, crs_ = mycrs,  prev_mask = NULL)  # simulate data for uniform state-space and habitat mask data3d = sim_classic(X = traps, ext = Grid$ext, crs_ = mycrs, sigma_ =  mysigma, prop_sex = 1, N = 200, K = 4, base_encounter = 0.15,  enc_dist = \"binomial\",hab_mask = hab_mask, setSeed = 50)  # get initial activity center starting values s.st3d = initialize_classic(y=data3d$y, M=500, X=traps, buff = 3*mysigma,  hab_mask = hab_mask)  # rescale inputs rescale_list = rescale_classic(X = traps, ext = Grid$ext, s.st = s.st3d,  hab_mask = hab_mask)  # store rescaled extent ext = rescale_list$ext  # prepare data data = list(y=data3d$y) # remove augmented records data$y = data$y[which(apply(data$y, 1, sum)!=0),,]  data$y = apply(data$y, c(1,2), sum) # covert to 2d by summing over occasions  # add rescaled traps data$X = rescale_list$X  # prepare constants constants = list(M = 500,n0 = nrow(data$y),J=dim(data$y)[2],                   K=dim(data3d$y)[3],x_lower = ext[1], x_upper = ext[2],                   y_lower = ext[3], y_upper = ext[4],sigma_upper = 1000,                   A = sum(hab_mask)*(pixelWidth)^2,pixelWidth=pixelWidth)  # add z and zeros vector data for latent inclusion indicator data$z = c(rep(1,constants$n0),rep(NA,constants$M - constants$n0)) data$zeros =  c(rep(NA,constants$n0),rep(0,constants$M - constants$n0))  # add hab_mask and OK for habitat check data$hab_mask = hab_mask data$OK = rep(1,constants$M)  # get initial activity center starting values s.st3d = rescale_list$s.st  # define all initial values inits = list(sigma = runif(1, 250, 350), s = s.st3d,psi=runif(1,0.2,0.3),           p0 = runif(1, 0.05, 0.15),   pOK = data$OK,            z=c(rep(NA,constants$n0),rep(0,constants$M-constants$n0)))  # parameters to monitor params = c(\"sigma\",\"psi\",\"p0\",\"N\",\"D\")  # get model scr_model = get_classic(dim_y = 2, enc_dist = \"binomial\",sex_sigma = FALSE, hab_mask=TRUE)  # run model library(tictoc) tic() # track time elapsed out = run_classic(model = scr_model, data=data, constants=constants,        inits=inits, params = params, niter = 1000, nburnin=500,        thin=1, nchains=2, parallel=TRUE, RNGseed = 500) toc()  # summarize output samples = do.call(rbind, out) par(mfrow=c(1,1)) hist(samples[,which(dimnames(out[[1]])[[2]]==\"N\")], xlab = \"Abundance\",  xlim = c(0,500), main=\"\") abline(v=200, col=\"red\") # add line for simulated abundance  # not run #nimSummary(out) }"},{"path":"https://sitkensis22.github.io/localSCR/reference/sim_classic.html","id":null,"dir":"Reference","previous_headings":"","what":"Function to simulate basic spatial capture-recapture data — sim_classic","title":"Function to simulate basic spatial capture-recapture data — sim_classic","text":"Returns list simulated data including encounter history, binary sex indicator, activity centers, site identifier.","code":""},{"path":"https://sitkensis22.github.io/localSCR/reference/sim_classic.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Function to simulate basic spatial capture-recapture data — sim_classic","text":"","code":"sim_classic(   X,   ext,   crs_,   N,   sigma_,   prop_sex,   K,   base_encounter,   enc_dist = \"binomial\",   hab_mask = FALSE,   setSeed = 500 )"},{"path":"https://sitkensis22.github.io/localSCR/reference/sim_classic.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Function to simulate basic spatial capture-recapture data — sim_classic","text":"X either matrix array object representing coordinates traps UTMs. array used traps clustered survey area. ext Extent object raster package.  returned grid_classic. crs_ UTM coordinate reference system (EPSG code) used location provided integer (e.g., 32608 WGS 84/UTM Zone 8N). N simulated total abundance integer. sigma_ scaling parameter bivariate normal kernel either meters kilometers integer. prop_sex portion females males numeric value. depend upon indicator coding scheme used (e.g., females = 1 males = 0; proportion females simulation). Must numeric value 0 1. Note 0 1 can used non-sex-specific  sigma desired. K number sampling occasions desired integer. base_encounter baseline encounter probability rate numeric value. Note probabilty given \"binomial\" observation distribution rate given \"poisson\" distribution. enc_dist either \"binomial\" \"poisson\". Default \"binomial\". hab_mask either FALSE (default) matrix arrary output mask_polygon mask_raster functions. setSeed random number generater seed integer used simulations obtain repeatable data simulations. Default 500.","code":""},{"path":"https://sitkensis22.github.io/localSCR/reference/sim_classic.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Function to simulate basic spatial capture-recapture data — sim_classic","text":"list matrix array encounter histories y, vector matrix 0's 1's sex, batrix simulated activity centers s, 3-dimensional trap array given, vector site identifier site.","code":""},{"path":"https://sitkensis22.github.io/localSCR/reference/sim_classic.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Function to simulate basic spatial capture-recapture data — sim_classic","text":"function supports spatial capture-recapture (SCR) analysis  allowing easy simulation data components used nimble Baysian  SCR models. Note output encounter histories y sorted detected detected individuals.","code":""},{"path":[]},{"path":"https://sitkensis22.github.io/localSCR/reference/sim_classic.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Function to simulate basic spatial capture-recapture data — sim_classic","text":"Daniel Eacker","code":""},{"path":"https://sitkensis22.github.io/localSCR/reference/sim_classic.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Function to simulate basic spatial capture-recapture data — sim_classic","text":"","code":"# simulate a single trap array with random positional noise x <- seq(-800, 800, length.out = 5) y <- seq(-800, 800, length.out = 5) traps <- as.matrix(expand.grid(x = x, y = y))  # add some random noise to locations traps <- traps + runif(prod(dim(traps)),-20,20)   mysigma = 300 # simulate sigma of 300 m mycrs = 32608 # EPSG for WGS 84 / UTM zone 8N  # Create grid and extent Grid = grid_classic(X = traps, crs_ = mycrs, buff = 3*mysigma, res = 100)  # simulate SCR data data3d = sim_classic(X = traps, ext = Grid$ext, crs_ = mycrs, sigma_ = c(300),  prop_sex = 1, N = 200, K = 4, base_encounter = 0.25, enc_dist = \"binomial\",  hab_mask = FALSE, setSeed = 50)  # make simple plot par(mfrow=c(1,1)) plot(Grid$grid, pch=20,ylab=\"Northing\",xlab=\"Easting\") points(traps, col=\"blue\",pch=20) points(data3d$s,col=\"red\",pch = 20) points(data3d$s[which(apply(data3d$y,1,sum)!=0),],col=\"green\",pch = 20)"}]
